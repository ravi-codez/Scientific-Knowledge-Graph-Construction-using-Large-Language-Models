{"s": "Doubly linked list", "p": "Used-for", "o": "Forward and reverse traversal", "id": 1, "concept": "end end"}
{"s": "Add", "p": "Part-of", "o": "MinHeapify", "id": 1, "concept": "end end"}
{"s": "Remove", "p": "Part-of", "o": "MinHeapify", "id": 1, "concept": "end end"}
{"s": "Add", "p": "Part-of", "o": "Linked list", "id": 1, "concept": "end end"}
{"s": "Remove", "p": "Part-of", "o": "Linked list", "id": 1, "concept": "end end"}
{"s": "Contains", "p": "Part-of", "o": "Linked list", "id": 1, "concept": "end end"}
{"s": "ReverseTraversal", "p": "Part-of", "o": "Linked list", "id": 1, "concept": "end end"}
{"s": "Insert", "p": "Part-of", "o": "Linked list", "id": 1, "concept": "end end"}
{"s": "InsertNode", "p": "Part-of", "o": "Linked list", "id": 1, "concept": "end end"}
{"s": "FindParent", "p": "Part-of", "o": "Tree", "id": 1, "concept": "end end"}
{"s": "FindNode", "p": "Part-of", "o": "Tree", "id": 1, "concept": "end end"}
{"s": "FindMin", "p": "Part-of", "o": "Tree", "id": 1, "concept": "end end"}
{"s": "FindMax", "p": "Part-of", "o": "Tree", "id": 1, "concept": "end end"}
{"s": "Preorder", "p": "Part-of", "o": "Tree", "id": 1, "concept": "end end"}
{"s": "Inorder", "p": "Part-of", "o": "Tree", "id": 1, "concept": "end end"}
{"s": "BreadthFirst", "p": "Part-of", "o": "Tree", "id": 1, "concept": "end end"}
{"s": "LeftRotation", "p": "Part-of", "o": "Tree", "id": 1, "concept": "end end"}
{"s": "CheckBalance", "p": "Part-of", "o": "Tree", "id": 1, "concept": "end end"}
{"s": "Remove", "p": "Part-of", "o": "Tree", "id": 1, "concept": "end end"}
{"s": "Mergesort", "p": "Hyponym-Of", "o": "Sorting algorithm", "id": 1, "concept": "end end"}
{"s": "Insertionsort", "p": "Hyponym-Of", "o": "Sorting algorithm", "id": 1, "concept": "end end"}
{"s": "ShellSort", "p": "Hyponym-Of", "o": "Sorting algorithm", "id": 1, "concept": "end end"}
{"s": "Radix", "p": "Hyponym-Of", "o": "Sorting algorithm", "id": 1, "concept": "end end"}
{"s": "GreatestCommonDenominator", "p": "Hyponym-Of", "o": "Algorithm", "id": 1, "concept": "end end"}
{"s": "SequentialSearch", "p": "Hyponym-Of", "o": "Searching algorithm", "id": 1, "concept": "end end"}
{"s": "ReverseWords", "p": "Hyponym-Of", "o": "Algorithm", "id": 1, "concept": "end end"}
{"s": "RepeatedWordCount", "p": "Hyponym-Of", "o": "Algorithm", "id": 1, "concept": "end end"}
{"s": "Any", "p": "Hyponym-Of", "o": "Algorithm", "id": 1, "concept": "end end"}
{"s": "Pseudocode", "p": "Is-a-Prerequisite-of", "o": "Algorithm implementation", "id": 1, "concept": "end end"}
{"s": "Algorithm", "p": "Evaluate-for", "o": "Efficiency", "id": 1, "concept": "end end"}
{"s": "Data structures", "p": "Is-a-Prerequisite-of", "o": "Algorithm design", "id": 1, "concept": "end end"}
{"s": "Hash table", "p": "Used-for", "o": "Efficient searching", "id": 1, "concept": "end end"}
{"s": "Queue", "p": "Part-of", "o": "Double Ended Queue", "id": 1, "concept": "end end"}
{"s": "Iterative algorithms", "p": "Compare", "o": "Recursive algorithms", "id": 1, "concept": "end end"}
{"s": "Appendix D", "p": "Part-of", "o": "Testing", "id": 1, "concept": "end end"}
{"s": "Appendix E", "p": "Part-of", "o": "Symbols", "id": 1, "concept": "end end"}
{"s": "Doubly linked list", "p": "Is-a-Prerequisite-of", "o": "efficient searching", "id": 2, "concept": "using tdd"}
{"s": "Queue", "p": "Hyponym-Of", "o": "Double Ended Queue", "id": 2, "concept": "using tdd"}
{"s": "Dequeue", "p": "Is-a-Prerequisite-of", "o": "efficient searching", "id": 2, "concept": "using tdd"}
{"s": "Iterative algorithms", "p": "Compare", "o": "Recursive algorithms", "id": 2, "concept": "using tdd"}
{"s": "Hash table", "p": "Used-for", "o": "efficient searching", "id": 2, "concept": "using tdd"}
{"s": "Searching algorithms", "p": "Evaluate-for", "o": "efficiency", "id": 2, "concept": "using tdd"}
{"s": "Data structures", "p": "Is-a-Prerequisite-of", "o": "algorithm efficiency", "id": 2, "concept": "using tdd"}
{"s": "Pseudocode", "p": "Used-for", "o": "algorithm implementation", "id": 2, "concept": "using tdd"}
{"s": "Algorithm", "p": "Part-of", "o": "Data Structure and Algorithm", "id": 2, "concept": "using tdd"}
{"s": "Testing", "p": "Part-of", "o": "Software Development", "id": 2, "concept": "using tdd"}
{"s": "Appendix D", "p": "Part-of", "o": "Appendix E", "id": 2, "concept": "using tdd"}
{"s": "Appendix E", "p": "Conjunction", "o": "Appendix D", "id": 2, "concept": "using tdd"}
{"s": "Binary Tree", "p": "Part-of", "o": "Tree", "id": 2, "concept": "using tdd"}
{"s": "Binary Search Tree", "p": "Hyponym-Of", "o": "Binary Tree", "id": 2, "concept": "using tdd"}
{"s": "MinHeap", "p": "Part-of", "o": "Heap", "id": 2, "concept": "using tdd"}
{"s": "Heap", "p": "Part-of", "o": "Data Structure", "id": 2, "concept": "using tdd"}
{"s": "Node", "p": "Part-of", "o": "Tree", "id": 2, "concept": "using tdd"}
{"s": "Node", "p": "Part-of", "o": "List", "id": 2, "concept": "using tdd"}
{"s": "Head node", "p": "Part-of", "o": "List", "id": 2, "concept": "using tdd"}
{"s": "Node", "p": "Part-of", "o": "Binary Tree", "id": 2, "concept": "using tdd"}
{"s": "Mergesort", "p": "Hyponym-Of", "o": "Sorting Algorithm", "id": 2, "concept": "using tdd"}
{"s": "Insertionsort", "p": "Hyponym-Of", "o": "Sorting Algorithm", "id": 2, "concept": "using tdd"}
{"s": "Shellsort", "p": "Hyponym-Of", "o": "Sorting Algorithm", "id": 2, "concept": "using tdd"}
{"s": "Radix", "p": "Hyponym-Of", "o": "Sorting Algorithm", "id": 2, "concept": "using tdd"}
{"s": "SequentialSearch", "p": "Hyponym-Of", "o": "Searching Algorithm", "id": 2, "concept": "using tdd"}
{"s": "ordered set", "p": "Part-of", "o": "set", "id": 0, "concept": "set member ordered"}
{"s": "unordered set", "p": "Part-of", "o": "set", "id": 0, "concept": "set member ordered"}
{"s": "ordered set", "p": "Compare", "o": "unordered set", "id": 0, "concept": "set member ordered"}
{"s": "set member", "p": "Part-of", "o": "set", "id": 0, "concept": "set member ordered"}
{"s": "ordered", "p": "Is-a-Prerequisite-of", "o": "ordered set", "id": 0, "concept": "set member ordered"}
{"s": "unordered", "p": "Is-a-Prerequisite-of", "o": "unordered set", "id": 0, "concept": "set member ordered"}
{"s": "ordered set", "p": "Is-a-Prerequisite-of", "o": "set member ordered", "id": 1, "concept": "chapter 11 string"}
{"s": "unordered set", "p": "Is-a-Prerequisite-of", "o": "set member ordered", "id": 1, "concept": "chapter 11 string"}
{"s": "ordered", "p": "Conjunction", "o": "unordered", "id": 1, "concept": "chapter 11 string"}
{"s": "set", "p": "Part-of", "o": "set member ordered", "id": 1, "concept": "chapter 11 string"}
{"s": "ordered", "p": "Compare", "o": "unordered", "id": 1, "concept": "chapter 11 string"}
{"s": "ordered set", "p": "Compare", "o": "unordered set", "id": 2, "concept": "end index list count"}
{"s": "ordered set", "p": "Part-of", "o": "set", "id": 2, "concept": "end index list count"}
{"s": "unordered set", "p": "Part-of", "o": "set", "id": 2, "concept": "end index list count"}
{"s": "set member", "p": "Part-of", "o": "set", "id": 2, "concept": "end index list count"}
{"s": "ordered", "p": "Is-a-Prerequisite-of", "o": "ordered set", "id": 2, "concept": "end index list count"}
{"s": "list", "p": "Is-a-Prerequisite-of", "o": "sorted list", "id": 0, "concept": "list sorted"}
{"s": "quick sort", "p": "Compare", "o": "other sorting algorithms", "id": 0, "concept": "list sorted"}
{"s": "linked list", "p": "Part-of", "o": "node", "id": 0, "concept": "list sorted"}
{"s": "linked list", "p": "Part-of", "o": "node", "id": 0, "concept": "list sorted"}
{"s": "sorted list", "p": "Used-for", "o": "merging", "id": 0, "concept": "list sorted"}
{"s": "list", "p": "Part-of", "o": "item", "id": 0, "concept": "list sorted"}
{"s": "insertion sort", "p": "Compare", "o": "quick sort", "id": 0, "concept": "list sorted"}
{"s": "list", "p": "Part-of", "o": "linked list", "id": 1, "concept": "end end end end"}
{"s": "list", "p": "Used-for", "o": "sorting", "id": 1, "concept": "end end end end"}
{"s": "quick sort", "p": "Compare", "o": "other sorting algorithms", "id": 1, "concept": "end end end end"}
{"s": "sorted lists", "p": "Conjunction", "o": "unsorted lists", "id": 1, "concept": "end end end end"}
{"s": "list", "p": "Part-of", "o": "node", "id": 1, "concept": "end end end end"}
{"s": "linked list", "p": "Part-of", "o": "node", "id": 1, "concept": "end end end end"}
{"s": "list sorted", "p": "Is-a-Prerequisite-of", "o": "merging the sorted lists back together", "id": 2, "concept": "set enforces prede\ufb01ned comparison"}
{"s": "list sorted", "p": "Compare", "o": "unsorted", "id": 2, "concept": "set enforces prede\ufb01ned comparison"}
{"s": "list sorted", "p": "Compare", "o": "implicitly sorted", "id": 2, "concept": "set enforces prede\ufb01ned comparison"}
{"s": "list", "p": "Part-of", "o": "node", "id": 2, "concept": "set enforces prede\ufb01ned comparison"}
{"s": "linked list", "p": "Part-of", "o": "node", "id": 2, "concept": "set enforces prede\ufb01ned comparison"}
{"s": "singly linked list", "p": "Hyponym-Of", "o": "linked list", "id": 2, "concept": "set enforces prede\ufb01ned comparison"}
{"s": "doubly linked list", "p": "Hyponym-Of", "o": "linked list", "id": 2, "concept": "set enforces prede\ufb01ned comparison"}
{"s": "quick sort", "p": "Compare", "o": "other sorting methods", "id": 2, "concept": "set enforces prede\ufb01ned comparison"}
{"s": "quick sort", "p": "Evaluate-for", "o": "efficiency", "id": 2, "concept": "set enforces prede\ufb01ned comparison"}
{"s": "recursive algorithm", "p": "Is-a-Prerequisite-of", "o": "Appendix C", "id": 0, "concept": "recursive algorithm"}
{"s": "recursive algorithm", "p": "Compare", "o": "iterative algorithm", "id": 0, "concept": "recursive algorithm"}
{"s": "recursive algorithm", "p": "Part-of", "o": "Algorithms", "id": 0, "concept": "recursive algorithm"}
{"s": "recursive algorithm", "p": "Used-for", "o": "tree", "id": 0, "concept": "recursive algorithm"}
{"s": "recursive algorithm", "p": "Evaluate-for", "o": "efficiency", "id": 0, "concept": "recursive algorithm"}
{"s": "recursive algorithm", "p": "Conjunction", "o": "iterative algorithms", "id": 0, "concept": "recursive algorithm"}
{"s": "iterative algorithm", "p": "Compare", "o": "recursive algorithm", "id": 0, "concept": "recursive algorithm"}
{"s": "Insertion sort", "p": "Hyponym-Of", "o": "Algorithm", "id": 0, "concept": "recursive algorithm"}
{"s": "Algorithm", "p": "Part-of", "o": "data structure", "id": 0, "concept": "recursive algorithm"}
{"s": "resizing algorithm", "p": "Used-for", "o": "data structure", "id": 0, "concept": "recursive algorithm"}
{"s": "recursive algorithm", "p": "Is-a-Prerequisite-of", "o": "recursive calls", "id": 1, "concept": "numberbase algorithm maxvalue"}
{"s": "recursive algorithm", "p": "Compare", "o": "iterative algorithm", "id": 1, "concept": "numberbase algorithm maxvalue"}
{"s": "recursive algorithm", "p": "Used-for", "o": "tree", "id": 1, "concept": "numberbase algorithm maxvalue"}
{"s": "recursive algorithm", "p": "Part-of", "o": "Algorithms", "id": 1, "concept": "numberbase algorithm maxvalue"}
{"s": "iterative algorithm", "p": "Compare", "o": "recursive algorithm", "id": 1, "concept": "numberbase algorithm maxvalue"}
{"s": "Algorithms", "p": "Part-of", "o": "Insertion sort", "id": 1, "concept": "numberbase algorithm maxvalue"}
{"s": "resizing algorithm", "p": "Used-for", "o": "data structure", "id": 1, "concept": "numberbase algorithm maxvalue"}
{"s": "data structure", "p": "Part-of", "o": "Algorithms", "id": 1, "concept": "numberbase algorithm maxvalue"}
{"s": "recursive algorithm", "p": "Is-a-Prerequisite-of", "o": "recursive calls", "id": 2, "concept": "queue enqueue root left"}
{"s": "recursive algorithm", "p": "Compare", "o": "iterative algorithm", "id": 2, "concept": "queue enqueue root left"}
{"s": "recursive algorithm", "p": "Used-for", "o": "tree\u2019s", "id": 2, "concept": "queue enqueue root left"}
{"s": "recursive algorithm", "p": "Evaluate-for", "o": "stack size", "id": 2, "concept": "queue enqueue root left"}
{"s": "recursive algorithm", "p": "Part-of", "o": "Algorithms", "id": 2, "concept": "queue enqueue root left"}
{"s": "iterative algorithm", "p": "Compare", "o": "recursive algorithm", "id": 2, "concept": "queue enqueue root left"}
{"s": "Algorithms", "p": "Part-of", "o": "Insertion sort", "id": 2, "concept": "queue enqueue root left"}
{"s": "Algorithms", "p": "Part-of", "o": "Intersection algorithm", "id": 2, "concept": "queue enqueue root left"}
{"s": "Algorithms", "p": "Part-of", "o": "resizing algorithm", "id": 2, "concept": "queue enqueue root left"}
{"s": "resizing algorithm", "p": "Used-for", "o": "data structure", "id": 2, "concept": "queue enqueue root left"}
{"s": "data structure", "p": "Part-of", "o": "recursive algorithm", "id": 2, "concept": "queue enqueue root left"}
{"s": "data structure", "p": "Part-of", "o": "iterative algorithm", "id": 2, "concept": "queue enqueue root left"}
{"s": "Height", "p": "Part-of", "o": "Tree", "id": 0, "concept": "height current left"}
{"s": "Height", "p": "Used-for", "o": "Balancing", "id": 0, "concept": "height current left"}
{"s": "Left", "p": "Part-of", "o": "Tree", "id": 0, "concept": "height current left"}
{"s": "Left", "p": "Conjunction", "o": "Right", "id": 0, "concept": "height current left"}
{"s": "Height", "p": "Compare", "o": "Height", "id": 0, "concept": "height current left"}
{"s": "current", "p": "Part-of", "o": "Tree", "id": 0, "concept": "height current left"}
{"s": "Height", "p": "Part-of", "o": "Tree", "id": 1, "concept": "solution need represent type"}
{"s": "Height", "p": "Used-for", "o": "Balance Factor", "id": 1, "concept": "solution need represent type"}
{"s": "current", "p": "Part-of", "o": "Tree", "id": 1, "concept": "solution need represent type"}
{"s": "Left", "p": "Part-of", "o": "Tree", "id": 1, "concept": "solution need represent type"}
{"s": "Left", "p": "Part-of", "o": "Node", "id": 1, "concept": "solution need represent type"}
{"s": "Right", "p": "Part-of", "o": "Node", "id": 1, "concept": "solution need represent type"}
{"s": "Height", "p": "Compare", "o": "Height", "id": 1, "concept": "solution need represent type"}
{"s": "Height", "p": "Compare", "o": "Height", "id": 1, "concept": "solution need represent type"}
{"s": "Balance Factor", "p": "Evaluate-for", "o": "Tree", "id": 1, "concept": "solution need represent type"}
{"s": "Left", "p": "Conjunction", "o": "Right", "id": 1, "concept": "solution need represent type"}
{"s": "Height", "p": "Part-of", "o": "Tree", "id": 2, "concept": "end end end inword"}
{"s": "Height", "p": "Used-for", "o": "Balancing", "id": 2, "concept": "end end end inword"}
{"s": "Height", "p": "Compare", "o": "Height", "id": 2, "concept": "end end end inword"}
{"s": "Left", "p": "Part-of", "o": "Tree", "id": 2, "concept": "end end end inword"}
{"s": "current", "p": "Part-of", "o": "Tree", "id": 2, "concept": "end end end inword"}
{"s": "Left", "p": "Compare", "o": "Right", "id": 2, "concept": "end end end inword"}
{"s": "understand algorithm", "p": "Is-a-Prerequisite-of", "o": "design algorithm", "id": 0, "concept": "understand algorithm"}
{"s": "algorithm", "p": "Part-of", "o": "data structures and algorithms", "id": 0, "concept": "understand algorithm"}
{"s": "AlgorithmName", "p": "Part-of", "o": "data structures and algorithms", "id": 0, "concept": "understand algorithm"}
{"s": "algorithm", "p": "Used-for", "o": "solve problem", "id": 0, "concept": "understand algorithm"}
{"s": "algorithm", "p": "Compare", "o": "algorithm", "id": 0, "concept": "understand algorithm"}
{"s": "Insertion sort", "p": "Hyponym-Of", "o": "algorithm", "id": 0, "concept": "understand algorithm"}
{"s": "Merge sort", "p": "Hyponym-Of", "o": "algorithm", "id": 0, "concept": "understand algorithm"}
{"s": "algorithm", "p": "Evaluate-for", "o": "runtime efficiency", "id": 0, "concept": "understand algorithm"}
{"s": "algorithm", "p": "Evaluate-for", "o": "space time complexity", "id": 0, "concept": "understand algorithm"}
{"s": "algorithm", "p": "Used-for", "o": "sorting", "id": 0, "concept": "understand algorithm"}
{"s": "Cubic algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 0, "concept": "understand algorithm"}
{"s": "Exponential algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 0, "concept": "understand algorithm"}
{"s": "Quadratic algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 0, "concept": "understand algorithm"}
{"s": "Insertion algorithm", "p": "Part-of", "o": "Binary search trees", "id": 0, "concept": "understand algorithm"}
{"s": "Deletion algorithm", "p": "Part-of", "o": "Binary search trees", "id": 0, "concept": "understand algorithm"}
{"s": "Contains algorithm", "p": "Part-of", "o": "Binary search trees", "id": 0, "concept": "understand algorithm"}
{"s": "FindMin algorithm", "p": "Part-of", "o": "Binary search trees", "id": 0, "concept": "understand algorithm"}
{"s": "FindMax algorithm", "p": "Part-of", "o": "Binary search trees", "id": 0, "concept": "understand algorithm"}
{"s": "Intersection algorithm", "p": "Part-of", "o": "Binary search trees", "id": 0, "concept": "understand algorithm"}
{"s": "Right rotation algorithm", "p": "Conjunction", "o": "Left rotation algorithm", "id": 0, "concept": "understand algorithm"}
{"s": "understand algorithm", "p": "Used-for", "o": "implement algorithm", "id": 0, "concept": "understand algorithm"}
{"s": "implementation", "p": "Part-of", "o": "understand algorithm", "id": 0, "concept": "understand algorithm"}
{"s": "recursion", "p": "Used-for", "o": "algorithm", "id": 0, "concept": "understand algorithm"}
{"s": "algorithm", "p": "Evaluate-for", "o": "run time efficiency", "id": 0, "concept": "understand algorithm"}
{"s": "custom type check", "p": "Is-a-Prerequisite-of", "o": "type T", "id": 0, "concept": "custom type check"}
{"s": "custom type check", "p": "Is-a-Prerequisite-of", "o": "value", "id": 1, "concept": "postorder root left"}
{"s": "custom type check", "p": "Is-a-Prerequisite-of", "o": "type T", "id": 2, "concept": "message summary summary summary"}
{"s": "custom type check", "p": "Is-a-Prerequisite-of", "o": "value", "id": 3, "concept": "left height current"}
{"s": "custom type check", "p": "Is-a-Prerequisite-of", "o": "type T", "id": 4, "concept": "set ordered"}
{"s": "custom type check", "p": "Is-a-Prerequisite-of", "o": "type T", "id": 5, "concept": "chapter introduction chapter"}
{"s": "custom type check", "p": "Is-a-Prerequisite-of", "o": "type T", "id": 6, "concept": "lot simpler"}
{"s": "custom type check", "p": "Is-a-Prerequisite-of", "o": "type T", "id": 7, "concept": "uniques set figure 11"}
{"s": "sorted value", "p": "Part-of", "o": "ascending order", "id": 0, "concept": "sorted value ascending order"}
{"s": "ascending order", "p": "Compare", "o": "descending order", "id": 0, "concept": "sorted value ascending order"}
{"s": "sorted value", "p": "Is-a-Prerequisite-of", "o": "Inorder", "id": 0, "concept": "sorted value ascending order"}
{"s": "sorted value", "p": "Is-a-Prerequisite-of", "o": "Ordered", "id": 0, "concept": "sorted value ascending order"}
{"s": "Inorder", "p": "Conjunction", "o": "Ordered", "id": 0, "concept": "sorted value ascending order"}
{"s": "ascending order", "p": "Used-for", "o": "sorting algorithm", "id": 0, "concept": "sorted value ascending order"}
{"s": "sorted value", "p": "Part-of", "o": "ascending order", "id": 1, "concept": "list pivot"}
{"s": "sorted value", "p": "Is-a-Prerequisite-of", "o": "list", "id": 1, "concept": "list pivot"}
{"s": "ascending order", "p": "Compare", "o": "descending order", "id": 1, "concept": "list pivot"}
{"s": "list", "p": "Used-for", "o": "sorting algorithm", "id": 1, "concept": "list pivot"}
{"s": "ascending order", "p": "Is-a-Prerequisite-of", "o": "sorted value", "id": 2, "concept": "ascending order post"}
{"s": "sorted value", "p": "Part-of", "o": "list", "id": 2, "concept": "ascending order post"}
{"s": "list", "p": "Used-for", "o": "ascending order", "id": 2, "concept": "ascending order post"}
{"s": "ascending order", "p": "Conjunction", "o": "descending order", "id": 2, "concept": "ascending order post"}
{"s": "Inorder", "p": "Hyponym-Of", "o": "sorted value", "id": 2, "concept": "ascending order post"}
{"s": "Ordered", "p": "Hyponym-Of", "o": "sorted value", "id": 2, "concept": "ascending order post"}
{"s": "sorted value", "p": "Part-of", "o": "ascending order", "id": 3, "concept": "summary summary summary"}
{"s": "ascending order", "p": "Compare", "o": "descending order", "id": 3, "concept": "summary summary summary"}
{"s": "sorted value", "p": "Is-a-Prerequisite-of", "o": "Inorder", "id": 3, "concept": "summary summary summary"}
{"s": "sorted value", "p": "Is-a-Prerequisite-of", "o": "Ordered", "id": 3, "concept": "summary summary summary"}
{"s": "Inorder", "p": "Conjunction", "o": "Ordered", "id": 3, "concept": "summary summary summary"}
{"s": "list", "p": "Part-of", "o": "return", "id": 1, "concept": "list return list return"}
{"s": "list", "p": "Hyponym-Of", "o": "data structure", "id": 2, "concept": "detail final message summary"}
{"s": "return statement", "p": "Part-of", "o": "function", "id": 2, "concept": "detail final message summary"}
{"s": "return statement", "p": "Used-for", "o": "returning values", "id": 2, "concept": "detail final message summary"}
{"s": "function", "p": "Part-of", "o": "program", "id": 2, "concept": "detail final message summary"}
{"s": "list", "p": "Used-for", "o": "data storage", "id": 2, "concept": "detail final message summary"}
{"s": "list", "p": "Compare", "o": "array", "id": 2, "concept": "detail final message summary"}
{"s": "0", "p": "Conjunction", "o": "1", "id": 2, "concept": "detail final message summary"}
{"s": "0", "p": "Compare", "o": "-1", "id": 2, "concept": "detail final message summary"}
{"s": "1", "p": "Compare", "o": "-1", "id": 2, "concept": "detail final message summary"}
{"s": "factorial", "p": "Is-a-Prerequisite-of", "o": "number", "id": 0, "concept": "number compute factorial post"}
{"s": "number", "p": "Used-for", "o": "factorial", "id": 0, "concept": "number compute factorial post"}
{"s": "n", "p": "Part-of", "o": "factorial", "id": 0, "concept": "number compute factorial post"}
{"s": "n", "p": "Is-a-Prerequisite-of", "o": "factorial", "id": 0, "concept": "number compute factorial post"}
{"s": "factorial", "p": "Is-a-Prerequisite-of", "o": "number", "id": 1, "concept": "figure show step inserting"}
{"s": "number", "p": "Used-for", "o": "factorial", "id": 1, "concept": "figure show step inserting"}
{"s": "n", "p": "Is-a-Prerequisite-of", "o": "factorial", "id": 1, "concept": "figure show step inserting"}
{"s": "n", "p": "Part-of", "o": "factorial", "id": 1, "concept": "figure show step inserting"}
{"s": "factorial", "p": "Is-a-Prerequisite-of", "o": "number", "id": 2, "concept": "singly linked list"}
{"s": "number", "p": "Used-for", "o": "factorial", "id": 2, "concept": "singly linked list"}
{"s": "n", "p": "Is-a-Prerequisite-of", "o": "factorial", "id": 2, "concept": "singly linked list"}
{"s": "increment", "p": "Part-of", "o": "list", "id": 0, "concept": "increment list increment"}
{"s": "increment", "p": "Used-for", "o": "list", "id": 0, "concept": "increment list increment"}
{"s": "list", "p": "Part-of", "o": "increment", "id": 1, "concept": "recursive algorithm appendix use"}
{"s": "increment", "p": "Used-for", "o": "list", "id": 1, "concept": "recursive algorithm appendix use"}
{"s": "list", "p": "Part-of", "o": "increment", "id": 2, "concept": "product unit testing"}
{"s": "increment", "p": "Used-for", "o": "list", "id": 2, "concept": "product unit testing"}
{"s": "return statement", "p": "Part-of", "o": "algorithm", "id": 0, "concept": "return list"}
{"s": "return statement", "p": "Used-for", "o": "function", "id": 0, "concept": "return list"}
{"s": "recursive algorithm", "p": "Is-a-Prerequisite-of", "o": "return statement", "id": 0, "concept": "return list"}
{"s": "return statement", "p": "Compare", "o": "while loop", "id": 0, "concept": "return list"}
{"s": "return statement", "p": "Compare", "o": "for loop", "id": 0, "concept": "return list"}
{"s": "return statement", "p": "Used-for", "o": "function call", "id": 0, "concept": "return list"}
{"s": "Fibonacci algorithm", "p": "Hyponym-Of", "o": "recursive algorithm", "id": 0, "concept": "return list"}
{"s": "return statement", "p": "Used-for", "o": "data structure", "id": 0, "concept": "return list"}
{"s": "heap", "p": "Part-of", "o": "data structure", "id": 0, "concept": "return list"}
{"s": "list", "p": "Part-of", "o": "data structure", "id": 0, "concept": "return list"}
{"s": "BST", "p": "Part-of", "o": "data structure", "id": 0, "concept": "return list"}
{"s": "Avl", "p": "Part-of", "o": "data structure", "id": 0, "concept": "return list"}
{"s": "return statement", "p": "Used-for", "o": "conditional statement", "id": 0, "concept": "return list"}
{"s": "return statement", "p": "Used-for", "o": "iterative algorithm", "id": 0, "concept": "return list"}
{"s": "function", "p": "Part-of", "o": "program", "id": 0, "concept": "return list"}
{"s": "algorithm", "p": "Part-of", "o": "program", "id": 0, "concept": "return list"}
{"s": "function call", "p": "Part-of", "o": "program", "id": 0, "concept": "return list"}
{"s": "conditional statement", "p": "Part-of", "o": "program", "id": 0, "concept": "return list"}
{"s": "iterative algorithm", "p": "Part-of", "o": "program", "id": 0, "concept": "return list"}
{"s": "data structure", "p": "Part-of", "o": "program", "id": 0, "concept": "return list"}
{"s": "return statement", "p": "Part-of", "o": "algorithm", "id": 1, "concept": "set2 pre list"}
{"s": "return statement", "p": "Used-for", "o": "function", "id": 1, "concept": "set2 pre list"}
{"s": "recursive algorithm", "p": "Is-a-Prerequisite-of", "o": "return statement", "id": 1, "concept": "set2 pre list"}
{"s": "call chain", "p": "Part-of", "o": "recursive algorithm", "id": 1, "concept": "set2 pre list"}
{"s": "Fibonacci algorithm", "p": "Hyponym-Of", "o": "recursive algorithm", "id": 1, "concept": "set2 pre list"}
{"s": "return statement", "p": "Compare", "o": "\u2205", "id": 1, "concept": "set2 pre list"}
{"s": "return statement", "p": "Compare", "o": "value", "id": 1, "concept": "set2 pre list"}
{"s": "return value", "p": "Part-of", "o": "return statement", "id": 1, "concept": "set2 pre list"}
{"s": "list", "p": "Used-for", "o": "return statement", "id": 1, "concept": "set2 pre list"}
{"s": "return statement", "p": "Is-a-Prerequisite-of", "o": "algorithm", "id": 2, "concept": "algorithm remove head value"}
{"s": "return statement", "p": "Used-for", "o": "function", "id": 2, "concept": "algorithm remove head value"}
{"s": "return statement", "p": "Part-of", "o": "recursive algorithm", "id": 2, "concept": "algorithm remove head value"}
{"s": "recursive algorithm", "p": "Part-of", "o": "algorithm", "id": 2, "concept": "algorithm remove head value"}
{"s": "algorithm", "p": "Is-a-Prerequisite-of", "o": "return type", "id": 2, "concept": "algorithm remove head value"}
{"s": "return type", "p": "Part-of", "o": "function", "id": 2, "concept": "algorithm remove head value"}
{"s": "Fibonacci algorithm", "p": "Hyponym-Of", "o": "recursive algorithm", "id": 2, "concept": "algorithm remove head value"}
{"s": "return statement", "p": "Compare", "o": "list", "id": 2, "concept": "algorithm remove head value"}
{"s": "return statement", "p": "Compare", "o": "\u2205", "id": 2, "concept": "algorithm remove head value"}
{"s": "return statement", "p": "Used-for", "o": "heap", "id": 2, "concept": "algorithm remove head value"}
{"s": "heap", "p": "Part-of", "o": "data structure", "id": 2, "concept": "algorithm remove head value"}
{"s": "list", "p": "Part-of", "o": "data structure", "id": 2, "concept": "algorithm remove head value"}
{"s": "return statement", "p": "Used-for", "o": "BST", "id": 2, "concept": "algorithm remove head value"}
{"s": "BST", "p": "Hyponym-Of", "o": "tree", "id": 2, "concept": "algorithm remove head value"}
{"s": "Avl", "p": "Hyponym-Of", "o": "tree", "id": 2, "concept": "algorithm remove head value"}
{"s": "Selecting correct sorting algorithm", "p": "Evaluate-for", "o": "Efficiency", "id": 0, "concept": "selecting correct sorting algorithm"}
{"s": "Sorting algorithms", "p": "Part-of", "o": "Algorithms", "id": 0, "concept": "selecting correct sorting algorithm"}
{"s": "Iterative algorithms", "p": "Hyponym-Of", "o": "Algorithms", "id": 0, "concept": "selecting correct sorting algorithm"}
{"s": "Sorting", "p": "Conjunction", "o": "Selecting correct sorting algorithm", "id": 0, "concept": "selecting correct sorting algorithm"}
{"s": "Selecting correct sorting algorithm", "p": "Is-a-Prerequisite-of", "o": "Efficiency", "id": 1, "concept": "greater equal greater inequality"}
{"s": "Sorting algorithms", "p": "Part-of", "o": "Algorithms", "id": 1, "concept": "greater equal greater inequality"}
{"s": "Iterative algorithms", "p": "Hyponym-Of", "o": "Algorithms", "id": 1, "concept": "greater equal greater inequality"}
{"s": "Selecting correct sorting algorithm", "p": "Used-for", "o": "Efficiency", "id": 1, "concept": "greater equal greater inequality"}
{"s": "Sorting", "p": "Part-of", "o": "Algorithms", "id": 1, "concept": "greater equal greater inequality"}
{"s": "Selecting correct sorting algorithm", "p": "Evaluate-for", "o": "Efficiency", "id": 2, "concept": "left preorder root"}
{"s": "Sorting algorithms", "p": "Is-a-Prerequisite-of", "o": "Algorithms", "id": 2, "concept": "left preorder root"}
{"s": "Iterative algorithms", "p": "Hyponym-Of", "o": "Algorithms", "id": 2, "concept": "left preorder root"}
{"s": "Sorting", "p": "Part-of", "o": "Algorithms", "id": 2, "concept": "left preorder root"}
{"s": "Selecting correct sorting algorithm", "p": "Used-for", "o": "Efficiency", "id": 2, "concept": "left preorder root"}
{"s": "Match", "p": "Part-of", "o": "Figure", "id": 0, "concept": "step match occurred figure"}
{"s": "First Step", "p": "Part-of", "o": "Match", "id": 0, "concept": "step match occurred figure"}
{"s": "Second Step", "p": "Part-of", "o": "Match", "id": 0, "concept": "step match occurred figure"}
{"s": "Match", "p": "Part-of", "o": "Figure 11.5", "id": 1, "concept": "summary summary description"}
{"s": "First Step", "p": "Conjunction", "o": "Second Step", "id": 1, "concept": "summary summary description"}
{"s": "First Step", "p": "Part-of", "o": "Match", "id": 1, "concept": "summary summary description"}
{"s": "Second Step", "p": "Part-of", "o": "Match", "id": 1, "concept": "summary summary description"}
{"s": "step", "p": "Part-of", "o": "match", "id": 2, "concept": "ascending order post list"}
{"s": "step", "p": "Part-of", "o": "figure", "id": 2, "concept": "ascending order post list"}
{"s": "match", "p": "Is-a-Prerequisite-of", "o": "step", "id": 2, "concept": "ascending order post list"}
{"s": "Match", "p": "Part-of", "o": "Figure 11.5", "id": 3, "concept": "pre list"}
{"s": "First Step", "p": "Conjunction", "o": "Second Step", "id": 3, "concept": "pre list"}
{"s": "Match", "p": "Is-a-Prerequisite-of", "o": "Second Step", "id": 3, "concept": "pre list"}
{"s": "First Step", "p": "Part-of", "o": "Match", "id": 3, "concept": "pre list"}
{"s": "Second Step", "p": "Part-of", "o": "Match", "id": 3, "concept": "pre list"}
{"s": "Match", "p": "Part-of", "o": "Figure 11.5", "id": 4, "concept": "programming language"}
{"s": "Step", "p": "Conjunction", "o": "Match", "id": 4, "concept": "programming language"}
{"s": "First Step", "p": "Part-of", "o": "Match", "id": 4, "concept": "programming language"}
{"s": "Second Step", "p": "Part-of", "o": "Match", "id": 4, "concept": "programming language"}
{"s": "Figure 11.1", "p": "Part-of", "o": "String", "id": 0, "concept": "set figure 11"}
{"s": "Figure 11.2", "p": "Part-of", "o": "Array", "id": 0, "concept": "set figure 11"}
{"s": "Figure 11.4", "p": "Compare", "o": "Figure 11.5", "id": 0, "concept": "set figure 11"}
{"s": "Figure 7.1", "p": "Part-of", "o": "Binary Search Tree", "id": 0, "concept": "set figure 11"}
{"s": "Figure 7.2", "p": "Part-of", "o": "Binary Search Tree", "id": 0, "concept": "set figure 11"}
{"s": "Figure A.2", "p": "Part-of", "o": "Recursive call chain", "id": 0, "concept": "set figure 11"}
{"s": "Figure 11.1", "p": "Part-of", "o": "String Indexing", "id": 1, "concept": "tree binary search tree"}
{"s": "Figure 11.2", "p": "Part-of", "o": "String Indexing", "id": 1, "concept": "tree binary search tree"}
{"s": "Figure 11.4", "p": "Compare", "o": "Figure 11.5", "id": 1, "concept": "tree binary search tree"}
{"s": "Figure 11.5", "p": "Part-of", "o": "String Matching", "id": 1, "concept": "tree binary search tree"}
{"s": "Figure 7.1", "p": "Part-of", "o": "Binary Search Tree", "id": 1, "concept": "tree binary search tree"}
{"s": "Figure 7.2", "p": "Part-of", "o": "Binary Search Tree", "id": 1, "concept": "tree binary search tree"}
{"s": "Figure A.2", "p": "Part-of", "o": "Recursive Call Chain", "id": 1, "concept": "tree binary search tree"}
{"s": "String Indexing", "p": "Used-for", "o": "String Matching", "id": 1, "concept": "tree binary search tree"}
{"s": "Binary Search Tree", "p": "Is-a-Prerequisite-of", "o": "Worst Case Scenario", "id": 1, "concept": "tree binary search tree"}
{"s": "Figure 11.1", "p": "Part-of", "o": "String", "id": 2, "concept": "list return item list"}
{"s": "Figure 11.2", "p": "Part-of", "o": "Array", "id": 2, "concept": "list return item list"}
{"s": "Figure 11.4", "p": "Compare", "o": "Figure 11.5", "id": 2, "concept": "list return item list"}
{"s": "Figure 11.5", "p": "Part-of", "o": "Match", "id": 2, "concept": "list return item list"}
{"s": "Figure 7.1", "p": "Part-of", "o": "BST", "id": 2, "concept": "list return item list"}
{"s": "Figure 7.2", "p": "Part-of", "o": "Worst-case-scenario", "id": 2, "concept": "list return item list"}
{"s": "Figure A.2", "p": "Part-of", "o": "Recursive-call-chain", "id": 2, "concept": "list return item list"}
{"s": "Figure 11.1", "p": "Part-of", "o": "String", "id": 3, "concept": "data structure"}
{"s": "Figure 11.2", "p": "Part-of", "o": "Array", "id": 3, "concept": "data structure"}
{"s": "Figure 11.4", "p": "Compare", "o": "Figure 11.5", "id": 3, "concept": "data structure"}
{"s": "Figure 11.5", "p": "Part-of", "o": "Match", "id": 3, "concept": "data structure"}
{"s": "Figure 7.1", "p": "Part-of", "o": "Subtree", "id": 3, "concept": "data structure"}
{"s": "Figure 7.2", "p": "Part-of", "o": "BST", "id": 3, "concept": "data structure"}
{"s": "Figure A.2", "p": "Part-of", "o": "Recursive Call Chain", "id": 3, "concept": "data structure"}
{"s": "Figure 11.1", "p": "Part-of", "o": "String", "id": 4, "concept": "current left height"}
{"s": "Figure 11.2", "p": "Part-of", "o": "Array", "id": 4, "concept": "current left height"}
{"s": "Figure 11.4", "p": "Compare", "o": "Figure 11.5", "id": 4, "concept": "current left height"}
{"s": "Figure 11.5", "p": "Part-of", "o": "Match location", "id": 4, "concept": "current left height"}
{"s": "Figure 7.1", "p": "Part-of", "o": "Subtree Condition", "id": 4, "concept": "current left height"}
{"s": "Figure 7.2", "p": "Part-of", "o": "Worst-case BST scenario", "id": 4, "concept": "current left height"}
{"s": "Figure A.2", "p": "Part-of", "o": "Recursive call chain", "id": 4, "concept": "current left height"}
{"s": "TDD", "p": "Is-a-Prerequisite-of", "o": "writing tests", "id": 0, "concept": "use tdd"}
{"s": "TDD", "p": "Compare", "o": "testing after implementing", "id": 0, "concept": "use tdd"}
{"s": "TDD", "p": "Evaluate-for", "o": "ease of use", "id": 0, "concept": "use tdd"}
{"s": "algorithm", "p": "Used-for", "o": "data structure", "id": 0, "concept": "use tdd"}
{"s": "algorithm", "p": "Evaluate-for", "o": "correctness", "id": 0, "concept": "use tdd"}
{"s": "data structure", "p": "Part-of", "o": "algorithm", "id": 0, "concept": "use tdd"}
{"s": "diagram", "p": "Used-for", "o": "visualise problem", "id": 0, "concept": "use tdd"}
{"s": "trace table", "p": "Used-for", "o": "verify algorithm correctness", "id": 0, "concept": "use tdd"}
{"s": "heap", "p": "Part-of", "o": "priority queue", "id": 0, "concept": "use tdd"}
{"s": "array", "p": "Part-of", "o": "heap", "id": 0, "concept": "use tdd"}
{"s": "BST", "p": "Compare", "o": "AVL tree", "id": 0, "concept": "use tdd"}
{"s": "hash table", "p": "Part-of", "o": "algorithm", "id": 0, "concept": "use tdd"}
{"s": "set", "p": "Used-for", "o": "algorithm", "id": 0, "concept": "use tdd"}
{"s": "queue", "p": "Hyponym-Of", "o": "data structure", "id": 0, "concept": "use tdd"}
{"s": "string", "p": "Part-of", "o": "algorithm", "id": 0, "concept": "use tdd"}
{"s": "TDD", "p": "Is-a-Prerequisite-of", "o": "writing tests", "id": 1, "concept": "recursive v iterative solution"}
{"s": "TDD", "p": "Compare", "o": "testing after implementing", "id": 1, "concept": "recursive v iterative solution"}
{"s": "algorithm", "p": "Used-for", "o": "data structure", "id": 1, "concept": "recursive v iterative solution"}
{"s": "algorithm", "p": "Evaluate-for", "o": "correctness", "id": 1, "concept": "recursive v iterative solution"}
{"s": "data structure", "p": "Part-of", "o": "algorithm", "id": 1, "concept": "recursive v iterative solution"}
{"s": "array", "p": "Part-of", "o": "heap", "id": 1, "concept": "recursive v iterative solution"}
{"s": "heap", "p": "Used-for", "o": "priority queue", "id": 1, "concept": "recursive v iterative solution"}
{"s": "BST", "p": "Compare", "o": "AVL tree", "id": 1, "concept": "recursive v iterative solution"}
{"s": "logarithmic searching algorithm", "p": "Used-for", "o": "AVL tree", "id": 1, "concept": "recursive v iterative solution"}
{"s": "logarithmic searching algorithm", "p": "Used-for", "o": "BST", "id": 1, "concept": "recursive v iterative solution"}
{"s": "hash table", "p": "Used-for", "o": "algorithm", "id": 1, "concept": "recursive v iterative solution"}
{"s": "set", "p": "Used-for", "o": "algorithm", "id": 1, "concept": "recursive v iterative solution"}
{"s": "diagram", "p": "Used-for", "o": "visualising problem", "id": 1, "concept": "recursive v iterative solution"}
{"s": "trace table", "p": "Used-for", "o": "verifying algorithm correctness", "id": 1, "concept": "recursive v iterative solution"}
{"s": "inheritance", "p": "Used-for", "o": "defining classes of tests", "id": 1, "concept": "recursive v iterative solution"}
{"s": "pseudocode", "p": "Part-of", "o": "algorithm description", "id": 1, "concept": "recursive v iterative solution"}
{"s": "TDD", "p": "Is-a-Prerequisite-of", "o": "writing tests", "id": 2, "concept": "true return false"}
{"s": "TDD", "p": "Compare", "o": "testing after implementing", "id": 2, "concept": "true return false"}
{"s": "testing", "p": "Used-for", "o": "creating a safety blanket", "id": 2, "concept": "true return false"}
{"s": "algorithm", "p": "Used-for", "o": "data structures", "id": 2, "concept": "true return false"}
{"s": "algorithm", "p": "Evaluate-for", "o": "correctness", "id": 2, "concept": "true return false"}
{"s": "algorithm", "p": "Part-of", "o": "software development", "id": 2, "concept": "true return false"}
{"s": "data structures", "p": "Part-of", "o": "algorithm", "id": 2, "concept": "true return false"}
{"s": "data structures", "p": "Used-for", "o": "storing data", "id": 2, "concept": "true return false"}
{"s": "array", "p": "Part-of", "o": "heap", "id": 2, "concept": "true return false"}
{"s": "heap", "p": "Used-for", "o": "priority queues", "id": 2, "concept": "true return false"}
{"s": "BST", "p": "Hyponym-Of", "o": "tree", "id": 2, "concept": "true return false"}
{"s": "AVL tree", "p": "Hyponym-Of", "o": "tree", "id": 2, "concept": "true return false"}
{"s": "hash table", "p": "Part-of", "o": "algorithm", "id": 2, "concept": "true return false"}
{"s": "priority queue", "p": "Is-a-Prerequisite-of", "o": "heap", "id": 2, "concept": "true return false"}
{"s": "pseudocode", "p": "Used-for", "o": "algorithm description", "id": 2, "concept": "true return false"}
{"s": "diagram", "p": "Used-for", "o": "visualising problem", "id": 2, "concept": "true return false"}
{"s": "trace table", "p": "Used-for", "o": "verifying algorithm correctness", "id": 2, "concept": "true return false"}
{"s": "inheritance", "p": "Used-for", "o": "defining classes of tests", "id": 2, "concept": "true return false"}
{"s": "TDD", "p": "Is-a-Prerequisite-of", "o": "Testing", "id": 3, "concept": "value delete algorithm"}
{"s": "TDD", "p": "Compare", "o": "Testing after implementing", "id": 3, "concept": "value delete algorithm"}
{"s": "Algorithms", "p": "Used-for", "o": "Data Structures", "id": 3, "concept": "value delete algorithm"}
{"s": "Data Structures", "p": "Part-of", "o": "Algorithms", "id": 3, "concept": "value delete algorithm"}
{"s": "Heap", "p": "Part-of", "o": "Array", "id": 3, "concept": "value delete algorithm"}
{"s": "Array", "p": "Used-for", "o": "Heap", "id": 3, "concept": "value delete algorithm"}
{"s": "Priority Queue", "p": "Is-a-Prerequisite-of", "o": "Heap", "id": 3, "concept": "value delete algorithm"}
{"s": "BST", "p": "Compare", "o": "AVL tree", "id": 3, "concept": "value delete algorithm"}
{"s": "Logarithmic Searching Algorithm", "p": "Used-for", "o": "BST", "id": 3, "concept": "value delete algorithm"}
{"s": "Logarithmic Searching Algorithm", "p": "Used-for", "o": "AVL tree", "id": 3, "concept": "value delete algorithm"}
{"s": "String", "p": "Part-of", "o": "Palindrome Algorithm", "id": 3, "concept": "value delete algorithm"}
{"s": "Palindrome Algorithm", "p": "Used-for", "o": "String", "id": 3, "concept": "value delete algorithm"}
{"s": "Pseudocode", "p": "Used-for", "o": "Algorithm Design", "id": 3, "concept": "value delete algorithm"}
{"s": "Algorithm", "p": "Evaluate-for", "o": "Trace Table", "id": 3, "concept": "value delete algorithm"}
{"s": "Diagram", "p": "Used-for", "o": "Algorithm Visualization", "id": 3, "concept": "value delete algorithm"}
{"s": "Trace Table", "p": "Used-for", "o": "Algorithm Verification", "id": 3, "concept": "value delete algorithm"}
{"s": "Inheritance", "p": "Used-for", "o": "Test Class Definition", "id": 3, "concept": "value delete algorithm"}
{"s": "Chapter", "p": "Part-of", "o": "Book", "id": 0, "concept": "chapter introduction chapter introduction"}
{"s": "Introduction", "p": "Part-of", "o": "Chapter", "id": 0, "concept": "chapter introduction chapter introduction"}
{"s": "Chapter", "p": "Conjunction", "o": "Chapter", "id": 0, "concept": "chapter introduction chapter introduction"}
{"s": "Chapter", "p": "Part-of", "o": "Book", "id": 1, "concept": "factorial post factorial"}
{"s": "Introduction", "p": "Part-of", "o": "Chapter", "id": 1, "concept": "factorial post factorial"}
{"s": "Chapter", "p": "Conjunction", "o": "Chapter", "id": 1, "concept": "factorial post factorial"}
{"s": "Chapter", "p": "Part-of", "o": "Book", "id": 2, "concept": "radix sort"}
{"s": "Introduction", "p": "Part-of", "o": "Chapter", "id": 2, "concept": "radix sort"}
{"s": "Chapter", "p": "Conjunction", "o": "Chapter", "id": 2, "concept": "radix sort"}
{"s": "Chapter", "p": "Part-of", "o": "Book", "id": 3, "concept": "faster big oh notation"}
{"s": "Introduction", "p": "Is-a-Prerequisite-of", "o": "Chapter", "id": 3, "concept": "faster big oh notation"}
{"s": "Doubly linked list", "p": "Is-a-Prerequisite-of", "o": "Reverse list traversal", "id": 0, "concept": "doubly linked list"}
{"s": "Doubly linked list", "p": "Compare", "o": "Singly linked list", "id": 0, "concept": "doubly linked list"}
{"s": "Doubly linked list", "p": "Part-of", "o": "Node", "id": 0, "concept": "doubly linked list"}
{"s": "Doubly linked list", "p": "Used-for", "o": "Non-trivial operations", "id": 0, "concept": "doubly linked list"}
{"s": "Singly linked list", "p": "Part-of", "o": "Node", "id": 0, "concept": "doubly linked list"}
{"s": "Singly linked list", "p": "Compare", "o": "Doubly linked list", "id": 0, "concept": "doubly linked list"}
{"s": "Singly linked list", "p": "Used-for", "o": "Basic insertions", "id": 0, "concept": "doubly linked list"}
{"s": "Singly linked list", "p": "Is-a-Prerequisite-of", "o": "Reverse list traversal", "id": 0, "concept": "doubly linked list"}
{"s": "Node", "p": "Part-of", "o": "Linked list", "id": 0, "concept": "doubly linked list"}
{"s": "Linked list", "p": "Conjunction", "o": "Head and tail", "id": 0, "concept": "doubly linked list"}
{"s": "Linked list", "p": "Part-of", "o": "Data Structure", "id": 0, "concept": "doubly linked list"}
{"s": "Linked list", "p": "Used-for", "o": "Insertion", "id": 0, "concept": "doubly linked list"}
{"s": "Linked list", "p": "Used-for", "o": "Deletion", "id": 0, "concept": "doubly linked list"}
{"s": "Linked list", "p": "Used-for", "o": "Traversal", "id": 0, "concept": "doubly linked list"}
{"s": "Doubly linked list", "p": "Is-a-Prerequisite-of", "o": "Reverse list traversal", "id": 1, "concept": "left preorder root right"}
{"s": "Doubly linked list", "p": "Compare", "o": "Singly linked list", "id": 1, "concept": "left preorder root right"}
{"s": "Doubly linked list", "p": "Part-of", "o": "Node", "id": 1, "concept": "left preorder root right"}
{"s": "Doubly linked list", "p": "Used-for", "o": "Non-trivial operations", "id": 1, "concept": "left preorder root right"}
{"s": "Singly linked list", "p": "Part-of", "o": "Node", "id": 1, "concept": "left preorder root right"}
{"s": "Singly linked list", "p": "Compare", "o": "Doubly linked list", "id": 1, "concept": "left preorder root right"}
{"s": "Singly linked list", "p": "Used-for", "o": "Basic insertions", "id": 1, "concept": "left preorder root right"}
{"s": "Singly linked list", "p": "Is-a-Prerequisite-of", "o": "Reverse list traversal", "id": 1, "concept": "left preorder root right"}
{"s": "Node", "p": "Part-of", "o": "Linked list", "id": 1, "concept": "left preorder root right"}
{"s": "Linked list", "p": "Conjunction", "o": "Head and tail", "id": 1, "concept": "left preorder root right"}
{"s": "Linked list", "p": "Part-of", "o": "Data Structure", "id": 1, "concept": "left preorder root right"}
{"s": "Linked list", "p": "Used-for", "o": "Insertion", "id": 1, "concept": "left preorder root right"}
{"s": "Linked list", "p": "Used-for", "o": "Deletion", "id": 1, "concept": "left preorder root right"}
{"s": "Linked list", "p": "Used-for", "o": "Traversal", "id": 1, "concept": "left preorder root right"}
{"s": "Head and tail", "p": "Part-of", "o": "Linked list", "id": 1, "concept": "left preorder root right"}
{"s": "Doubly linked list", "p": "Is-a-Prerequisite-of", "o": "Reverse list traversal", "id": 2, "concept": "oh notation run time"}
{"s": "Doubly linked list", "p": "Compare", "o": "Singly linked list", "id": 2, "concept": "oh notation run time"}
{"s": "Doubly linked list", "p": "Part-of", "o": "Node", "id": 2, "concept": "oh notation run time"}
{"s": "Doubly linked list", "p": "Used-for", "o": "Non-trivial operations", "id": 2, "concept": "oh notation run time"}
{"s": "Singly linked list", "p": "Part-of", "o": "Node", "id": 2, "concept": "oh notation run time"}
{"s": "Singly linked list", "p": "Compare", "o": "Doubly linked list", "id": 2, "concept": "oh notation run time"}
{"s": "Singly linked list", "p": "Used-for", "o": "Basic insertions", "id": 2, "concept": "oh notation run time"}
{"s": "Singly linked list", "p": "Is-a-Prerequisite-of", "o": "Reverse list traversal", "id": 2, "concept": "oh notation run time"}
{"s": "Linked list", "p": "Part-of", "o": "Node", "id": 2, "concept": "oh notation run time"}
{"s": "Linked list", "p": "Conjunction", "o": "Head and tail", "id": 2, "concept": "oh notation run time"}
{"s": "Node", "p": "Part-of", "o": "Linked list", "id": 2, "concept": "oh notation run time"}
{"s": "Head", "p": "Part-of", "o": "Linked list", "id": 2, "concept": "oh notation run time"}
{"s": "Tail", "p": "Part-of", "o": "Linked list", "id": 2, "concept": "oh notation run time"}
{"s": "Doubly linked list", "p": "Is-a-Prerequisite-of", "o": "Reverse list traversal", "id": 3, "concept": "unit testing"}
{"s": "Doubly linked list", "p": "Compare", "o": "Singly linked list", "id": 3, "concept": "unit testing"}
{"s": "Doubly linked list", "p": "Part-of", "o": "Node", "id": 3, "concept": "unit testing"}
{"s": "Doubly linked list", "p": "Used-for", "o": "Non-trivial operations", "id": 3, "concept": "unit testing"}
{"s": "Singly linked list", "p": "Part-of", "o": "Node", "id": 3, "concept": "unit testing"}
{"s": "Singly linked list", "p": "Compare", "o": "Doubly linked list", "id": 3, "concept": "unit testing"}
{"s": "Singly linked list", "p": "Used-for", "o": "Basic insertions", "id": 3, "concept": "unit testing"}
{"s": "Singly linked list", "p": "Is-a-Prerequisite-of", "o": "Reverse list traversal", "id": 3, "concept": "unit testing"}
{"s": "Linked list", "p": "Part-of", "o": "Node", "id": 3, "concept": "unit testing"}
{"s": "Linked list", "p": "Part-of", "o": "Head", "id": 3, "concept": "unit testing"}
{"s": "Linked list", "p": "Part-of", "o": "Tail", "id": 3, "concept": "unit testing"}
{"s": "Node", "p": "Part-of", "o": "Linked list", "id": 3, "concept": "unit testing"}
{"s": "Head", "p": "Part-of", "o": "Linked list", "id": 3, "concept": "unit testing"}
{"s": "Tail", "p": "Part-of", "o": "Linked list", "id": 3, "concept": "unit testing"}
{"s": "Insertion", "p": "Used-for", "o": "Linked list", "id": 3, "concept": "unit testing"}
{"s": "Deletion", "p": "Used-for", "o": "Linked list", "id": 3, "concept": "unit testing"}
{"s": "Traversal", "p": "Used-for", "o": "Linked list", "id": 3, "concept": "unit testing"}
{"s": "Doubly Linked List", "p": "Compare", "o": "Singly Linked List", "id": 4, "concept": "chapter binary search tree"}
{"s": "Doubly Linked List", "p": "Part-of", "o": "Node", "id": 4, "concept": "chapter binary search tree"}
{"s": "Singly Linked List", "p": "Part-of", "o": "Node", "id": 4, "concept": "chapter binary search tree"}
{"s": "Doubly Linked List", "p": "Used-for", "o": "Reverse Traversal", "id": 4, "concept": "chapter binary search tree"}
{"s": "Singly Linked List", "p": "Used-for", "o": "Basic Insertions", "id": 4, "concept": "chapter binary search tree"}
{"s": "Doubly Linked List", "p": "Used-for", "o": "Non-trivial operations", "id": 4, "concept": "chapter binary search tree"}
{"s": "Doubly Linked List", "p": "Used-for", "o": "Forward and Reverse Traversal", "id": 4, "concept": "chapter binary search tree"}
{"s": "Singly Linked List", "p": "Used-for", "o": "Basic Insertions", "id": 4, "concept": "chapter binary search tree"}
{"s": "Linked List", "p": "Part-of", "o": "Node", "id": 4, "concept": "chapter binary search tree"}
{"s": "Linked List", "p": "Is-a-Prerequisite-of", "o": "Pointer", "id": 4, "concept": "chapter binary search tree"}
{"s": "Linked List", "p": "Is-a-Prerequisite-of", "o": "Head", "id": 4, "concept": "chapter binary search tree"}
{"s": "Linked List", "p": "Is-a-Prerequisite-of", "o": "Tail", "id": 4, "concept": "chapter binary search tree"}
{"s": "list", "p": "Is-a-Prerequisite-of", "o": "Pre", "id": 1, "concept": "list list pre"}
{"s": "list", "p": "Part-of", "o": "singly linked list", "id": 3, "concept": "parent index index"}
{"s": "passed custom type check", "p": "Is-a-Prerequisite-of", "o": "value", "id": 0, "concept": "passed custom type check"}
{"s": "passed custom type check", "p": "Is-a-Prerequisite-of", "o": "value", "id": 1, "concept": "nodetoremove right nodetoremove left"}
{"s": "passed custom type check", "p": "Is-a-Prerequisite-of", "o": "value", "id": 2, "concept": "problem lot easier solve"}
{"s": "passed custom type check", "p": "Is-a-Prerequisite-of", "o": "value", "id": 3, "concept": "string just"}
{"s": "passed custom type check", "p": "Is-a-Prerequisite-of", "o": "type T", "id": 4, "concept": "remove algorithm"}
{"s": "Postorder", "p": "Is-a-Prerequisite-of", "o": "Binary Search Tree Traversal", "id": 0, "concept": "bst post node bst"}
{"s": "Postorder", "p": "Compare", "o": "Preorder", "id": 0, "concept": "bst post node bst"}
{"s": "Postorder", "p": "Compare", "o": "Inorder", "id": 0, "concept": "bst post node bst"}
{"s": "Binary Search Tree", "p": "Part-of", "o": "Node", "id": 0, "concept": "bst post node bst"}
{"s": "Binary Search Tree", "p": "Used-for", "o": "Data Storage", "id": 0, "concept": "bst post node bst"}
{"s": "Binary Search Tree", "p": "Evaluate-for", "o": "Search Efficiency", "id": 0, "concept": "bst post node bst"}
{"s": "Binary Search Tree", "p": "Evaluate-for", "o": "Space Complexity", "id": 0, "concept": "bst post node bst"}
{"s": "Binary Search Tree Traversal", "p": "Hyponym-Of", "o": "Tree Traversal", "id": 0, "concept": "bst post node bst"}
{"s": "Postorder", "p": "Is-a-Prerequisite-of", "o": "Binary Search Tree traversal", "id": 1, "concept": "value return root value"}
{"s": "Binary Search Tree", "p": "Part-of", "o": "Node", "id": 1, "concept": "value return root value"}
{"s": "Node", "p": "Part-of", "o": "Binary Search Tree", "id": 1, "concept": "value return root value"}
{"s": "Postorder", "p": "Compare", "o": "Preorder", "id": 1, "concept": "value return root value"}
{"s": "Postorder", "p": "Compare", "o": "Inorder", "id": 1, "concept": "value return root value"}
{"s": "Postorder", "p": "Is-a-Prerequisite-of", "o": "Binary Search Tree Traversal", "id": 2, "concept": "trouble speak manifest typically"}
{"s": "Postorder", "p": "Compare", "o": "Preorder", "id": 2, "concept": "trouble speak manifest typically"}
{"s": "Postorder", "p": "Compare", "o": "Inorder", "id": 2, "concept": "trouble speak manifest typically"}
{"s": "Binary Search Tree", "p": "Part-of", "o": "Node", "id": 2, "concept": "trouble speak manifest typically"}
{"s": "Binary Search Tree", "p": "Part-of", "o": "Root", "id": 2, "concept": "trouble speak manifest typically"}
{"s": "Binary Search Tree", "p": "Part-of", "o": "Leaf", "id": 2, "concept": "trouble speak manifest typically"}
{"s": "Node", "p": "Part-of", "o": "Binary Search Tree", "id": 2, "concept": "trouble speak manifest typically"}
{"s": "Postorder traversal", "p": "Is-a-Prerequisite-of", "o": "Binary Search Tree", "id": 3, "concept": "problem lot easier"}
{"s": "Postorder traversal", "p": "Compare", "o": "Preorder traversal", "id": 3, "concept": "problem lot easier"}
{"s": "Postorder traversal", "p": "Compare", "o": "Inorder traversal", "id": 3, "concept": "problem lot easier"}
{"s": "Postorder", "p": "Is-a-Prerequisite-of", "o": "Binary Search Tree Traversal", "id": 4, "concept": "left nodetoremove right null"}
{"s": "Binary Search Tree", "p": "Part-of", "o": "Node", "id": 4, "concept": "left nodetoremove right null"}
{"s": "Node", "p": "Part-of", "o": "Binary Search Tree", "id": 4, "concept": "left nodetoremove right null"}
{"s": "Postorder", "p": "Compare", "o": "Preorder", "id": 4, "concept": "left nodetoremove right null"}
{"s": "Postorder", "p": "Compare", "o": "Inorder", "id": 4, "concept": "left nodetoremove right null"}
{"s": "list index", "p": "Part-of", "o": "list", "id": 0, "concept": "list index item"}
{"s": "list", "p": "Used-for", "o": "item search", "id": 0, "concept": "list index item"}
{"s": "item", "p": "Compare", "o": "list index", "id": 0, "concept": "list index item"}
{"s": "index", "p": "Evaluate-for", "o": "item search", "id": 0, "concept": "list index item"}
{"s": "index", "p": "Part-of", "o": "algorithm", "id": 0, "concept": "list index item"}
{"s": "list", "p": "Part-of", "o": "index", "id": 2, "concept": "return true"}
{"s": "index", "p": "Used-for", "o": "item search", "id": 2, "concept": "return true"}
{"s": "list", "p": "Part-of", "o": "item", "id": 2, "concept": "return true"}
{"s": "index", "p": "Compare", "o": "list.Count", "id": 2, "concept": "return true"}
{"s": "item", "p": "Compare", "o": "list[index]", "id": 2, "concept": "return true"}
{"s": "list index", "p": "Part-of", "o": "list", "id": 3, "concept": "list increment hold increment"}
{"s": "list", "p": "Used-for", "o": "item search", "id": 3, "concept": "list increment hold increment"}
{"s": "item", "p": "Compare", "o": "list index", "id": 3, "concept": "list increment hold increment"}
{"s": "index", "p": "Used-for", "o": "item search", "id": 3, "concept": "list increment hold increment"}
{"s": "list", "p": "Part-of", "o": "index", "id": 4, "concept": "rotation algorithm"}
{"s": "item", "p": "Part-of", "o": "list", "id": 4, "concept": "rotation algorithm"}
{"s": "index", "p": "Used-for", "o": "search", "id": 4, "concept": "rotation algorithm"}
{"s": "list", "p": "Used-for", "o": "search", "id": 4, "concept": "rotation algorithm"}
{"s": "index", "p": "Compare", "o": "list.Count", "id": 4, "concept": "rotation algorithm"}
{"s": "32 bit integer", "p": "Is-a-Prerequisite-of", "o": "radix sort", "id": 0, "concept": "32 bit integer"}
{"s": "integer", "p": "Hyponym-Of", "o": "32 bit integer", "id": 0, "concept": "32 bit integer"}
{"s": "n", "p": "Is-a-Prerequisite-of", "o": "32 bit integer", "id": 0, "concept": "32 bit integer"}
{"s": "WORD", "p": "Compare", "o": "32 bit integer", "id": 0, "concept": "32 bit integer"}
{"s": "list", "p": "Compare", "o": "32 bit integer", "id": 0, "concept": "32 bit integer"}
{"s": "integer", "p": "Used-for", "o": "algorithm", "id": 0, "concept": "32 bit integer"}
{"s": "positive integers", "p": "Part-of", "o": "integer", "id": 0, "concept": "32 bit integer"}
{"s": "algorithm", "p": "Used-for", "o": "32 bit integer", "id": 0, "concept": "32 bit integer"}
{"s": "numberBase", "p": "Used-for", "o": "integer", "id": 0, "concept": "32 bit integer"}
{"s": "current right height", "p": "Part-of", "o": "AVL tree", "id": 0, "concept": "current right height"}
{"s": "current right height", "p": "Compare", "o": "left height", "id": 0, "concept": "current right height"}
{"s": "right", "p": "Part-of", "o": "current right height", "id": 0, "concept": "current right height"}
{"s": "current right height", "p": "Part-of", "o": "AVL tree", "id": 1, "concept": "set enforces prede\ufb01ned"}
{"s": "current right height", "p": "Compare", "o": "left height", "id": 1, "concept": "set enforces prede\ufb01ned"}
{"s": "InsertNode", "p": "Used-for", "o": "current right height", "id": 1, "concept": "set enforces prede\ufb01ned"}
{"s": "current right height", "p": "Part-of", "o": "Binary Search Tree", "id": 1, "concept": "set enforces prede\ufb01ned"}
{"s": "current right height", "p": "Part-of", "o": "AVL Tree", "id": 2, "concept": "overall problem"}
{"s": "current right height", "p": "Compare", "o": "left height", "id": 2, "concept": "overall problem"}
{"s": "InsertNode", "p": "Used-for", "o": "current right height", "id": 2, "concept": "overall problem"}
{"s": "tree balance", "p": "Is-a-Prerequisite-of", "o": "updating current height", "id": 2, "concept": "overall problem"}
{"s": "current right height", "p": "Part-of", "o": "AVL Tree", "id": 3, "concept": "greater equal"}
{"s": "current right height", "p": "Compare", "o": "left height", "id": 3, "concept": "greater equal"}
{"s": "InsertNode", "p": "Used-for", "o": "current right height", "id": 3, "concept": "greater equal"}
{"s": "current right height", "p": "Evaluate-for", "o": "tree balance", "id": 3, "concept": "greater equal"}
{"s": "Height", "p": "Part-of", "o": "current", "id": 0, "concept": "current left height current"}
{"s": "Height", "p": "Compare", "o": "Height", "id": 0, "concept": "current left height current"}
{"s": "current", "p": "Part-of", "o": "Left", "id": 0, "concept": "current left height current"}
{"s": "current", "p": "Part-of", "o": "AVL tree", "id": 1, "concept": "recursive v iterative"}
{"s": "current.Left", "p": "Part-of", "o": "AVL tree", "id": 1, "concept": "recursive v iterative"}
{"s": "current.Right", "p": "Part-of", "o": "AVL tree", "id": 1, "concept": "recursive v iterative"}
{"s": "Height", "p": "Compare", "o": "Height", "id": 2, "concept": "return root value yield"}
{"s": "current", "p": "Part-of", "o": "Height", "id": 2, "concept": "return root value yield"}
{"s": "Left", "p": "Part-of", "o": "current", "id": 2, "concept": "return root value yield"}
{"s": "current", "p": "Part-of", "o": "Left", "id": 2, "concept": "return root value yield"}
{"s": "Height", "p": "Compare", "o": "Height", "id": 3, "concept": "chapter avl tree avl"}
{"s": "current", "p": "Part-of", "o": "Height", "id": 3, "concept": "chapter avl tree avl"}
{"s": "current", "p": "Part-of", "o": "Left", "id": 3, "concept": "chapter avl tree avl"}
{"s": "Height", "p": "Compare", "o": "Height", "id": 4, "concept": "true false case case"}
{"s": "current", "p": "Part-of", "o": "Height", "id": 4, "concept": "true false case case"}
{"s": "current", "p": "Part-of", "o": "Left", "id": 4, "concept": "true false case case"}
{"s": "post list sorted", "p": "Is-a-Prerequisite-of", "o": "efficient search", "id": 0, "concept": "post list sorted"}
{"s": "post list sorted", "p": "Hyponym-Of", "o": "sorted list", "id": 0, "concept": "post list sorted"}
{"s": "post list sorted", "p": "Used-for", "o": "data retrieval", "id": 0, "concept": "post list sorted"}
{"s": "sorted list", "p": "Part-of", "o": "data structure", "id": 0, "concept": "post list sorted"}
{"s": "sorted list", "p": "Compare", "o": "unsorted list", "id": 0, "concept": "post list sorted"}
{"s": "efficient search", "p": "Evaluate-for", "o": "performance", "id": 0, "concept": "post list sorted"}
{"s": "data structure", "p": "Part-of", "o": "computer science", "id": 0, "concept": "post list sorted"}
{"s": "post list sorted", "p": "Is-a-Prerequisite-of", "o": "efficient search", "id": 1, "concept": "state end"}
{"s": "post list sorted", "p": "Hyponym-Of", "o": "sorted list", "id": 1, "concept": "state end"}
{"s": "post list sorted", "p": "Used-for", "o": "data retrieval", "id": 1, "concept": "state end"}
{"s": "sorted list", "p": "Part-of", "o": "data structure", "id": 1, "concept": "state end"}
{"s": "sorted list", "p": "Compare", "o": "unsorted list", "id": 1, "concept": "state end"}
{"s": "efficient search", "p": "Evaluate-for", "o": "post list sorted", "id": 1, "concept": "state end"}
{"s": "post list sorted", "p": "Is-a-Prerequisite-of", "o": "efficient search", "id": 2, "concept": "algorithm design"}
{"s": "post list sorted", "p": "Compare", "o": "unsorted list", "id": 2, "concept": "algorithm design"}
{"s": "post list sorted", "p": "Used-for", "o": "data retrieval", "id": 2, "concept": "algorithm design"}
{"s": "sorting algorithms", "p": "Part-of", "o": "computer science", "id": 2, "concept": "algorithm design"}
{"s": "sorting algorithms", "p": "Compare", "o": "search algorithms", "id": 2, "concept": "algorithm design"}
{"s": "efficient search", "p": "Is-a-Prerequisite-of", "o": "user experience", "id": 2, "concept": "algorithm design"}
{"s": "list", "p": "Is-a-Prerequisite-of", "o": "sorted list", "id": 3, "concept": "heap array used store"}
{"s": "sorted list", "p": "Part-of", "o": "post", "id": 3, "concept": "heap array used store"}
{"s": "list", "p": "Hyponym-Of", "o": "data structure", "id": 3, "concept": "heap array used store"}
{"s": "Height", "p": "Part-of", "o": "current", "id": 0, "concept": "right height current left"}
{"s": "Left", "p": "Part-of", "o": "current", "id": 0, "concept": "right height current left"}
{"s": "Right", "p": "Part-of", "o": "current", "id": 0, "concept": "right height current left"}
{"s": "current", "p": "Compare", "o": "Left", "id": 0, "concept": "right height current left"}
{"s": "current", "p": "Compare", "o": "Right", "id": 0, "concept": "right height current left"}
{"s": "Left", "p": "Compare", "o": "Right", "id": 0, "concept": "right height current left"}
{"s": "Height", "p": "Used-for", "o": "current", "id": 0, "concept": "right height current left"}
{"s": "Height", "p": "Part-of", "o": "current", "id": 1, "concept": "type check type type"}
{"s": "Left", "p": "Part-of", "o": "current", "id": 1, "concept": "type check type type"}
{"s": "Right", "p": "Part-of", "o": "current", "id": 1, "concept": "type check type type"}
{"s": "current", "p": "Compare", "o": "Left", "id": 1, "concept": "type check type type"}
{"s": "current", "p": "Compare", "o": "Right", "id": 1, "concept": "type check type type"}
{"s": "Left", "p": "Compare", "o": "Right", "id": 1, "concept": "type check type type"}
{"s": "Left", "p": "Part-of", "o": "current.Left", "id": 1, "concept": "type check type type"}
{"s": "Right", "p": "Part-of", "o": "current.Right", "id": 1, "concept": "type check type type"}
{"s": "Height", "p": "Part-of", "o": "current", "id": 2, "concept": "equality equal greater"}
{"s": "Left", "p": "Part-of", "o": "current", "id": 2, "concept": "equality equal greater"}
{"s": "Right", "p": "Part-of", "o": "current", "id": 2, "concept": "equality equal greater"}
{"s": "Height", "p": "Compare", "o": "Height", "id": 2, "concept": "equality equal greater"}
{"s": "Left", "p": "Compare", "o": "Right", "id": 2, "concept": "equality equal greater"}
{"s": "current", "p": "Used-for", "o": "Height", "id": 2, "concept": "equality equal greater"}
{"s": "Left", "p": "Used-for", "o": "Height", "id": 2, "concept": "equality equal greater"}
{"s": "Right", "p": "Used-for", "o": "Height", "id": 2, "concept": "equality equal greater"}
{"s": "Right", "p": "Part-of", "o": "Binary Tree", "id": 3, "concept": "introduction chapter"}
{"s": "Left", "p": "Part-of", "o": "Binary Tree", "id": 3, "concept": "introduction chapter"}
{"s": "current", "p": "Part-of", "o": "Binary Tree", "id": 3, "concept": "introduction chapter"}
{"s": "Height", "p": "Used-for", "o": "Binary Tree", "id": 3, "concept": "introduction chapter"}
{"s": "Height", "p": "Compare", "o": "Height", "id": 3, "concept": "introduction chapter"}
{"s": "Left", "p": "Compare", "o": "Right", "id": 3, "concept": "introduction chapter"}
{"s": "Left", "p": "Part-of", "o": "Node", "id": 3, "concept": "introduction chapter"}
{"s": "Right", "p": "Part-of", "o": "Node", "id": 3, "concept": "introduction chapter"}
{"s": "current", "p": "Part-of", "o": "Node", "id": 3, "concept": "introduction chapter"}
{"s": "Height", "p": "Part-of", "o": "current", "id": 4, "concept": "end end inword"}
{"s": "Left", "p": "Part-of", "o": "current", "id": 4, "concept": "end end inword"}
{"s": "Right", "p": "Part-of", "o": "current", "id": 4, "concept": "end end inword"}
{"s": "Height", "p": "Compare", "o": "Height", "id": 4, "concept": "end end inword"}
{"s": "Left", "p": "Compare", "o": "Right", "id": 4, "concept": "end end inword"}
{"s": "Left", "p": "Part-of", "o": "Left", "id": 4, "concept": "end end inword"}
{"s": "Right", "p": "Part-of", "o": "Right", "id": 4, "concept": "end end inword"}
{"s": "Height", "p": "Used-for", "o": "current", "id": 4, "concept": "end end inword"}
{"s": "nodeToRemove", "p": "Part-of", "o": "tree", "id": 0, "concept": "value nodetoremove left nodetoremove"}
{"s": "nodeToRemove", "p": "Is-a-Prerequisite-of", "o": "removal of a value", "id": 0, "concept": "value nodetoremove left nodetoremove"}
{"s": "leaf node", "p": "Is-a-Prerequisite-of", "o": "removal of a value", "id": 0, "concept": "value nodetoremove left nodetoremove"}
{"s": "root", "p": "Part-of", "o": "tree", "id": 0, "concept": "value nodetoremove left nodetoremove"}
{"s": "Left", "p": "Part-of", "o": "tree", "id": 0, "concept": "value nodetoremove left nodetoremove"}
{"s": "Right", "p": "Part-of", "o": "tree", "id": 0, "concept": "value nodetoremove left nodetoremove"}
{"s": "nodeToRemove", "p": "Compare", "o": "\u2205", "id": 0, "concept": "value nodetoremove left nodetoremove"}
{"s": "nodeToRemove.Value", "p": "Compare", "o": "Value", "id": 0, "concept": "value nodetoremove left nodetoremove"}
{"s": "nodeToRemove", "p": "Part-of", "o": "tree", "id": 0, "concept": "value nodetoremove left nodetoremove"}
{"s": "nodeToRemove", "p": "Part-of", "o": "tree", "id": 2, "concept": "recursive algorithm iterative solution"}
{"s": "nodeToRemove", "p": "Is-a-Prerequisite-of", "o": "removal of a leaf node", "id": 2, "concept": "recursive algorithm iterative solution"}
{"s": "nodeToRemove.Left", "p": "Part-of", "o": "nodeToRemove", "id": 2, "concept": "recursive algorithm iterative solution"}
{"s": "nodeToRemove.Right", "p": "Part-of", "o": "nodeToRemove", "id": 2, "concept": "recursive algorithm iterative solution"}
{"s": "leaf node", "p": "Hyponym-Of", "o": "node", "id": 2, "concept": "recursive algorithm iterative solution"}
{"s": "root", "p": "Part-of", "o": "tree", "id": 2, "concept": "recursive algorithm iterative solution"}
{"s": "nodeToRemove", "p": "Part-of", "o": "tree", "id": 3, "concept": "requires data structure expose"}
{"s": "nodeToRemove", "p": "Is-a-Prerequisite-of", "o": "removal of a leaf node", "id": 3, "concept": "requires data structure expose"}
{"s": "nodeToRemove.Left", "p": "Part-of", "o": "nodeToRemove", "id": 3, "concept": "requires data structure expose"}
{"s": "nodeToRemove.Right", "p": "Part-of", "o": "nodeToRemove", "id": 3, "concept": "requires data structure expose"}
{"s": "leaf node", "p": "Hyponym-Of", "o": "node", "id": 3, "concept": "requires data structure expose"}
{"s": "value", "p": "Part-of", "o": "node", "id": 3, "concept": "requires data structure expose"}
{"s": "nodeToRemove", "p": "Part-of", "o": "tree", "id": 4, "concept": "11 string"}
{"s": "nodeToRemove", "p": "Is-a-Prerequisite-of", "o": "removal of a leaf node", "id": 4, "concept": "11 string"}
{"s": "nodeToRemove", "p": "Is-a-Prerequisite-of", "o": "removal of a node", "id": 4, "concept": "11 string"}
{"s": "Left", "p": "Part-of", "o": "nodeToRemove", "id": 4, "concept": "11 string"}
{"s": "Right", "p": "Part-of", "o": "nodeToRemove", "id": 4, "concept": "11 string"}
{"s": "nodeToRemove", "p": "Compare", "o": "\u2205", "id": 4, "concept": "11 string"}
{"s": "Value", "p": "Part-of", "o": "nodeToRemove", "id": 4, "concept": "11 string"}
{"s": "Binary Search Tree", "p": "Is-a-Prerequisite-of", "o": "Searching", "id": 0, "concept": "tree binary search"}
{"s": "Binary Search Tree", "p": "Part-of", "o": "Root", "id": 0, "concept": "tree binary search"}
{"s": "Binary Search Tree", "p": "Compare", "o": "AVL Tree", "id": 0, "concept": "tree binary search"}
{"s": "AVL Tree", "p": "Hyponym-Of", "o": "Binary Search Tree", "id": 0, "concept": "tree binary search"}
{"s": "Binary Search Tree", "p": "Used-for", "o": "Representing data types", "id": 0, "concept": "tree binary search"}
{"s": "Tree Rotation", "p": "Used-for", "o": "Binary Search Tree", "id": 0, "concept": "tree binary search"}
{"s": "Searching", "p": "Conjunction", "o": "Binary Search", "id": 0, "concept": "tree binary search"}
{"s": "Binary Search", "p": "Compare", "o": "Binary Chop", "id": 0, "concept": "tree binary search"}
{"s": "Binary Search Tree", "p": "Is-a-Prerequisite-of", "o": "Searching", "id": 1, "concept": "summary summary summary description"}
{"s": "Binary Search Tree", "p": "Part-of", "o": "Data Structure", "id": 1, "concept": "summary summary summary description"}
{"s": "AVL Tree", "p": "Hyponym-Of", "o": "Binary Search Tree", "id": 1, "concept": "summary summary summary description"}
{"s": "Binary Search Tree", "p": "Compare", "o": "AVL Tree", "id": 1, "concept": "summary summary summary description"}
{"s": "Tree Rotation", "p": "Used-for", "o": "Binary Search Tree", "id": 1, "concept": "summary summary summary description"}
{"s": "Binary Search", "p": "Compare", "o": "Binary Search Tree", "id": 1, "concept": "summary summary summary description"}
{"s": "Inorder visit", "p": "Part-of", "o": "Binary Search Tree", "id": 1, "concept": "summary summary summary description"}
{"s": "Preorder visit", "p": "Part-of", "o": "Binary Search Tree", "id": 1, "concept": "summary summary summary description"}
{"s": "Postorder visit", "p": "Part-of", "o": "Binary Search Tree", "id": 1, "concept": "summary summary summary description"}
{"s": "Breadth First visit", "p": "Part-of", "o": "Binary Search Tree", "id": 1, "concept": "summary summary summary description"}
{"s": "Binary Search Tree", "p": "Is-a-Prerequisite-of", "o": "Searching", "id": 2, "concept": "make thing complex"}
{"s": "Binary Search Tree", "p": "Part-of", "o": "Root", "id": 2, "concept": "make thing complex"}
{"s": "Binary Search Tree", "p": "Compare", "o": "AVL Tree", "id": 2, "concept": "make thing complex"}
{"s": "AVL Tree", "p": "Hyponym-Of", "o": "Binary Search Tree", "id": 2, "concept": "make thing complex"}
{"s": "Binary Search Tree", "p": "Used-for", "o": "Searching", "id": 2, "concept": "make thing complex"}
{"s": "Tree", "p": "Part-of", "o": "Binary Search Tree", "id": 2, "concept": "make thing complex"}
{"s": "Tree rotation", "p": "Used-for", "o": "Binary Search Tree", "id": 2, "concept": "make thing complex"}
{"s": "Binary Search Tree", "p": "Is-a-Prerequisite-of", "o": "Searching", "id": 3, "concept": "item end index list"}
{"s": "Binary Search Tree", "p": "Part-of", "o": "Data Structure", "id": 3, "concept": "item end index list"}
{"s": "AVL Tree", "p": "Hyponym-Of", "o": "Binary Search Tree", "id": 3, "concept": "item end index list"}
{"s": "Binary Search Tree", "p": "Compare", "o": "AVL Tree", "id": 3, "concept": "item end index list"}
{"s": "Tree rotation", "p": "Used-for", "o": "Binary Search Tree", "id": 3, "concept": "item end index list"}
{"s": "Binary Search", "p": "Compare", "o": "Binary Search Tree", "id": 3, "concept": "item end index list"}
{"s": "Binary Search Tree", "p": "Is-a-Prerequisite-of", "o": "Searching", "id": 4, "concept": "list pre"}
{"s": "Binary Search Tree", "p": "Part-of", "o": "Root", "id": 4, "concept": "list pre"}
{"s": "Binary Search Tree", "p": "Compare", "o": "AVL Tree", "id": 4, "concept": "list pre"}
{"s": "AVL Tree", "p": "Hyponym-Of", "o": "Binary Search Tree", "id": 4, "concept": "list pre"}
{"s": "Tree Rotation", "p": "Used-for", "o": "Binary Search Tree", "id": 4, "concept": "list pre"}
{"s": "Inorder visit", "p": "Part-of", "o": "Binary Search Tree", "id": 4, "concept": "list pre"}
{"s": "Preorder visit", "p": "Part-of", "o": "Binary Search Tree", "id": 4, "concept": "list pre"}
{"s": "Postorder visit", "p": "Part-of", "o": "Binary Search Tree", "id": 4, "concept": "list pre"}
{"s": "Breadth First visit", "p": "Part-of", "o": "Binary Search Tree", "id": 4, "concept": "list pre"}
{"s": "Binary Search", "p": "Compare", "o": "Binary Search Tree", "id": 4, "concept": "list pre"}
{"s": "nodeToRemove", "p": "Part-of", "o": "Binary Search Tree", "id": 0, "concept": "nodetoremove left nodetoremove right"}
{"s": "nodeToRemove.Left", "p": "Part-of", "o": "Binary Search Tree", "id": 0, "concept": "nodetoremove left nodetoremove right"}
{"s": "nodeToRemove.Right", "p": "Part-of", "o": "Binary Search Tree", "id": 0, "concept": "nodetoremove left nodetoremove right"}
{"s": "nodeToRemove.Left", "p": "Compare", "o": "\u2205", "id": 0, "concept": "nodetoremove left nodetoremove right"}
{"s": "nodeToRemove.Right", "p": "Compare", "o": "\u2205", "id": 0, "concept": "nodetoremove left nodetoremove right"}
{"s": "nodeToRemove.Left", "p": "Compare", "o": "nodeToRemove.Right", "id": 0, "concept": "nodetoremove left nodetoremove right"}
{"s": "parent.Left", "p": "Part-of", "o": "Binary Search Tree", "id": 0, "concept": "nodetoremove left nodetoremove right"}
{"s": "nodeToRemove.Right", "p": "Part-of", "o": "Binary Search Tree", "id": 0, "concept": "nodetoremove left nodetoremove right"}
{"s": "nodeToRemove.Left", "p": "Part-of", "o": "Binary Search Tree", "id": 0, "concept": "nodetoremove left nodetoremove right"}
{"s": "nodeToRemove.Right", "p": "Part-of", "o": "Binary Search Tree", "id": 0, "concept": "nodetoremove left nodetoremove right"}
{"s": "nodeToRemove", "p": "Part-of", "o": "Binary Tree", "id": 1, "concept": "list pre list"}
{"s": "nodeToRemove.Left", "p": "Part-of", "o": "Binary Tree", "id": 1, "concept": "list pre list"}
{"s": "nodeToRemove.Right", "p": "Part-of", "o": "Binary Tree", "id": 1, "concept": "list pre list"}
{"s": "nodeToRemove.Left", "p": "Compare", "o": "\u2205", "id": 1, "concept": "list pre list"}
{"s": "nodeToRemove.Right", "p": "Compare", "o": "\u2205", "id": 1, "concept": "list pre list"}
{"s": "nodeToRemove.Left", "p": "Compare", "o": "nodeToRemove.Right", "id": 1, "concept": "list pre list"}
{"s": "parent.Left", "p": "Part-of", "o": "Binary Tree", "id": 1, "concept": "list pre list"}
{"s": "nodeToRemove.Right", "p": "Part-of", "o": "Binary Tree", "id": 1, "concept": "list pre list"}
{"s": "nodeToRemove.Left", "p": "Part-of", "o": "Binary Tree", "id": 1, "concept": "list pre list"}
{"s": "nodeToRemove", "p": "Part-of", "o": "Binary Search Tree", "id": 2, "concept": "list increment list increment"}
{"s": "nodeToRemove.Left", "p": "Part-of", "o": "Binary Search Tree", "id": 2, "concept": "list increment list increment"}
{"s": "nodeToRemove.Right", "p": "Part-of", "o": "Binary Search Tree", "id": 2, "concept": "list increment list increment"}
{"s": "nodeToRemove.Left", "p": "Compare", "o": "\u2205", "id": 2, "concept": "list increment list increment"}
{"s": "nodeToRemove.Right", "p": "Compare", "o": "\u2205", "id": 2, "concept": "list increment list increment"}
{"s": "nodeToRemove.Left", "p": "Compare", "o": "nodeToRemove.Right", "id": 2, "concept": "list increment list increment"}
{"s": "Binary Search Tree", "p": "Is-a-Prerequisite-of", "o": "AVL Tree", "id": 1, "concept": "binary search tree"}
{"s": "Binary Search Tree", "p": "Compare", "o": "AVL Tree", "id": 1, "concept": "binary search tree"}
{"s": "Binary Search Tree", "p": "Part-of", "o": "Root", "id": 1, "concept": "binary search tree"}
{"s": "Inorder visit", "p": "Part-of", "o": "Binary Search Tree", "id": 1, "concept": "binary search tree"}
{"s": "Preorder visit", "p": "Part-of", "o": "Binary Search Tree", "id": 1, "concept": "binary search tree"}
{"s": "Postorder visit", "p": "Part-of", "o": "Binary Search Tree", "id": 1, "concept": "binary search tree"}
{"s": "Breadth First visit", "p": "Part-of", "o": "Binary Search Tree", "id": 1, "concept": "binary search tree"}
{"s": "Binary Search Tree", "p": "Used-for", "o": "searching", "id": 1, "concept": "binary search tree"}
{"s": "AVL Tree", "p": "Hyponym-Of", "o": "Binary Search Tree", "id": 1, "concept": "binary search tree"}
{"s": "Tree rotation", "p": "Used-for", "o": "Binary Search Tree", "id": 1, "concept": "binary search tree"}
{"s": "Binary Search Tree", "p": "Is-a-Prerequisite-of", "o": "AVL Tree", "id": 2, "concept": "set2 pre list pre"}
{"s": "Binary Search Tree", "p": "Compare", "o": "AVL Tree", "id": 2, "concept": "set2 pre list pre"}
{"s": "Binary Search Tree", "p": "Part-of", "o": "Root", "id": 2, "concept": "set2 pre list pre"}
{"s": "Binary Search Tree", "p": "Part-of", "o": "Subtrees", "id": 2, "concept": "set2 pre list pre"}
{"s": "Binary Search Tree", "p": "Used-for", "o": "searching", "id": 2, "concept": "set2 pre list pre"}
{"s": "AVL Tree", "p": "Hyponym-Of", "o": "Binary Search Tree", "id": 2, "concept": "set2 pre list pre"}
{"s": "Tree Rotation", "p": "Used-for", "o": "Binary Search Tree", "id": 2, "concept": "set2 pre list pre"}
{"s": "Binary Search Tree", "p": "Is-a-Prerequisite-of", "o": "Searching", "id": 3, "concept": "linked list traversing"}
{"s": "Binary Search Tree", "p": "Part-of", "o": "Data Structure", "id": 3, "concept": "linked list traversing"}
{"s": "Binary Search Tree", "p": "Compare", "o": "AVL Tree", "id": 3, "concept": "linked list traversing"}
{"s": "Binary Search Tree", "p": "Used-for", "o": "Representing data types", "id": 3, "concept": "linked list traversing"}
{"s": "AVL Tree", "p": "Hyponym-Of", "o": "Binary Search Tree", "id": 3, "concept": "linked list traversing"}
{"s": "Tree rotation", "p": "Used-for", "o": "Balancing Binary Search Tree", "id": 3, "concept": "linked list traversing"}
{"s": "Binary Search", "p": "Compare", "o": "Binary Search Tree", "id": 3, "concept": "linked list traversing"}
{"s": "Binary Search Tree", "p": "Is-a-Prerequisite-of", "o": "Binary Search", "id": 4, "concept": "value yield root value"}
{"s": "Binary Search Tree", "p": "Compare", "o": "AVL Tree", "id": 4, "concept": "value yield root value"}
{"s": "AVL Tree", "p": "Hyponym-Of", "o": "Binary Search Tree", "id": 4, "concept": "value yield root value"}
{"s": "Binary Search Tree", "p": "Part-of", "o": "Root", "id": 4, "concept": "value yield root value"}
{"s": "Binary Search Tree", "p": "Part-of", "o": "Subtree", "id": 4, "concept": "value yield root value"}
{"s": "Tree Rotation", "p": "Used-for", "o": "Binary Search Tree", "id": 4, "concept": "value yield root value"}
{"s": "Binary Search", "p": "Compare", "o": "Binary Chop", "id": 4, "concept": "value yield root value"}
{"s": "Postorder", "p": "Is-a-Prerequisite-of", "o": "Right", "id": 0, "concept": "root right postorder postorder"}
{"s": "Right", "p": "Part-of", "o": "root", "id": 0, "concept": "root right postorder postorder"}
{"s": "Postorder", "p": "Is-a-Prerequisite-of", "o": "Right", "id": 1, "concept": "problem algorithm algorithm"}
{"s": "Postorder", "p": "Part-of", "o": "root", "id": 1, "concept": "problem algorithm algorithm"}
{"s": "right", "p": "Part-of", "o": "Postorder", "id": 1, "concept": "problem algorithm algorithm"}
{"s": "root", "p": "Part-of", "o": "Postorder", "id": 1, "concept": "problem algorithm algorithm"}
{"s": "Postorder", "p": "Part-of", "o": "Right", "id": 2, "concept": "mentation case yield overwhelming"}
{"s": "Postorder", "p": "Part-of", "o": "root", "id": 2, "concept": "mentation case yield overwhelming"}
{"s": "Postorder", "p": "Is-a-Prerequisite-of", "o": "Right", "id": 3, "concept": "number item heap heap"}
{"s": "Postorder", "p": "Part-of", "o": "root", "id": 3, "concept": "number item heap heap"}
{"s": "root", "p": "Part-of", "o": "Right", "id": 3, "concept": "number item heap heap"}
{"s": "Postorder", "p": "Is-a-Prerequisite-of", "o": "Right", "id": 4, "concept": "chapter avl"}
{"s": "Postorder", "p": "Part-of", "o": "root", "id": 4, "concept": "chapter avl"}
{"s": "Right", "p": "Part-of", "o": "root", "id": 4, "concept": "chapter avl"}
{"s": "Rotation", "p": "Is-a-Prerequisite-of", "o": "Algorithms", "id": 0, "concept": "rotation algorithm symmetric"}
{"s": "Rotation", "p": "Compare", "o": "Rotation", "id": 0, "concept": "rotation algorithm symmetric"}
{"s": "Iterative algorithms", "p": "Hyponym-Of", "o": "Algorithms", "id": 0, "concept": "rotation algorithm symmetric"}
{"s": "Rotation algorithm", "p": "Compare", "o": "Rotation algorithm", "id": 1, "concept": "sort algorithm fairly e\ufb03cient"}
{"s": "Rotation algorithm", "p": "Is-a-Prerequisite-of", "o": "Algorithms", "id": 1, "concept": "sort algorithm fairly e\ufb03cient"}
{"s": "Iterative algorithms", "p": "Conjunction", "o": "Rotation algorithm", "id": 1, "concept": "sort algorithm fairly e\ufb03cient"}
{"s": "Rotation algorithm", "p": "Compare", "o": "Rotation algorithm", "id": 2, "concept": "list list pre value"}
{"s": "Rotation algorithm", "p": "Is-a-Prerequisite-of", "o": "Algorithms", "id": 2, "concept": "list list pre value"}
{"s": "Iterative algorithms", "p": "Conjunction", "o": "Rotation algorithm", "id": 2, "concept": "list list pre value"}
{"s": "Rotation", "p": "Is-a-Prerequisite-of", "o": "Algorithms", "id": 3, "concept": "introduction book"}
{"s": "Rotation", "p": "Compare", "o": "Rotation", "id": 3, "concept": "introduction book"}
{"s": "Iterative algorithms", "p": "Hyponym-Of", "o": "Algorithms", "id": 3, "concept": "introduction book"}
{"s": "Contains algorithm", "p": "Part-of", "o": "Algorithms", "id": 3, "concept": "introduction book"}
{"s": "Rotation algorithm", "p": "Compare", "o": "Rotation algorithm", "id": 4, "concept": "enqueue 10"}
{"s": "Rotation algorithm", "p": "Is-a-Prerequisite-of", "o": "Algorithms", "id": 4, "concept": "enqueue 10"}
{"s": "Iterative algorithms", "p": "Conjunction", "o": "Rotation algorithm", "id": 4, "concept": "enqueue 10"}
{"s": "algorithm", "p": "Is-a-Prerequisite-of", "o": "data structure", "id": 0, "concept": "algorithm add"}
{"s": "algorithm", "p": "Used-for", "o": "problem solving", "id": 0, "concept": "algorithm add"}
{"s": "algorithm", "p": "Evaluate-for", "o": "efficiency", "id": 0, "concept": "algorithm add"}
{"s": "algorithm", "p": "Compare", "o": "algorithm", "id": 0, "concept": "algorithm add"}
{"s": "Big O notation", "p": "Used-for", "o": "algorithm analysis", "id": 0, "concept": "algorithm add"}
{"s": "asymptotic run time", "p": "Part-of", "o": "algorithm analysis", "id": 0, "concept": "algorithm add"}
{"s": "algorithm design", "p": "Part-of", "o": "algorithm", "id": 0, "concept": "algorithm add"}
{"s": "algorithm", "p": "Part-of", "o": "algorithm", "id": 0, "concept": "algorithm add"}
{"s": "Pre-condition", "p": "Part-of", "o": "algorithm", "id": 0, "concept": "algorithm add"}
{"s": "Post-condition", "p": "Part-of", "o": "algorithm", "id": 0, "concept": "algorithm add"}
{"s": "algorithm", "p": "Part-of", "o": "chapter", "id": 0, "concept": "algorithm add"}
{"s": "algorithm", "p": "Part-of", "o": "data structure", "id": 0, "concept": "algorithm add"}
{"s": "pseudocode", "p": "Used-for", "o": "algorithm design", "id": 0, "concept": "algorithm add"}
{"s": "test cases", "p": "Used-for", "o": "algorithm validation", "id": 0, "concept": "algorithm add"}
{"s": "algorithm", "p": "Evaluate-for", "o": "test cases", "id": 0, "concept": "algorithm add"}
{"s": "recursive algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 0, "concept": "algorithm add"}
{"s": "sorting algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 0, "concept": "algorithm add"}
{"s": "algorithm", "p": "Compare", "o": "algorithm", "id": 0, "concept": "algorithm add"}
{"s": "logarithmic algorithm", "p": "Compare", "o": "quadratic algorithm", "id": 0, "concept": "algorithm add"}
{"s": "quadratic algorithm", "p": "Compare", "o": "logarithmic algorithm", "id": 0, "concept": "algorithm add"}
{"s": "cubic algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 0, "concept": "algorithm add"}
{"s": "exponential algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 0, "concept": "algorithm add"}
{"s": "algorithm", "p": "Part-of", "o": "data structure and algorithms", "id": 0, "concept": "algorithm add"}
{"s": "algorithm", "p": "Conjunction", "o": "data structure", "id": 0, "concept": "algorithm add"}
{"s": "algorithm", "p": "Hyponym-Of", "o": "Add", "id": 1, "concept": "height current right height"}
{"s": "algorithm", "p": "Used-for", "o": "data structure", "id": 1, "concept": "height current right height"}
{"s": "algorithm", "p": "Evaluate-for", "o": "efficiency", "id": 1, "concept": "height current right height"}
{"s": "Big O notation", "p": "Used-for", "o": "algorithm", "id": 1, "concept": "height current right height"}
{"s": "algorithm", "p": "Part-of", "o": "data structures and algorithms", "id": 1, "concept": "height current right height"}
{"s": "logarithmic algorithm", "p": "Compare", "o": "quadratic algorithm", "id": 1, "concept": "height current right height"}
{"s": "prototype algorithm", "p": "Is-a-Prerequisite-of", "o": "algorithm design", "id": 1, "concept": "height current right height"}
{"s": "algorithm", "p": "Part-of", "o": "chapter", "id": 1, "concept": "height current right height"}
{"s": "algorithm", "p": "Part-of", "o": "section", "id": 1, "concept": "height current right height"}
{"s": "pseudocode", "p": "Part-of", "o": "algorithm", "id": 1, "concept": "height current right height"}
{"s": "test cases", "p": "Part-of", "o": "algorithm", "id": 1, "concept": "height current right height"}
{"s": "algorithm", "p": "Evaluate-for", "o": "minimised test driven development", "id": 1, "concept": "height current right height"}
{"s": "algorithm", "p": "Conjunction", "o": "data structures", "id": 1, "concept": "height current right height"}
{"s": "recursive algorithm", "p": "Is-a-Prerequisite-of", "o": "algorithm trace", "id": 1, "concept": "height current right height"}
{"s": "Add algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 1, "concept": "height current right height"}
{"s": "Contains algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 1, "concept": "height current right height"}
{"s": "Remove algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 1, "concept": "height current right height"}
{"s": "Traverse algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 1, "concept": "height current right height"}
{"s": "ReverseTraversal algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 1, "concept": "height current right height"}
{"s": "Insert algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 1, "concept": "height current right height"}
{"s": "InsertNode algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 1, "concept": "height current right height"}
{"s": "FindParent algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 1, "concept": "height current right height"}
{"s": "FindNode algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 1, "concept": "height current right height"}
{"s": "FindMin algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 1, "concept": "height current right height"}
{"s": "FindMax algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 1, "concept": "height current right height"}
{"s": "Preorder algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 1, "concept": "height current right height"}
{"s": "Postorder algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 1, "concept": "height current right height"}
{"s": "Inorder algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 1, "concept": "height current right height"}
{"s": "BreadthFirst algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 1, "concept": "height current right height"}
{"s": "MinHeapify algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 1, "concept": "height current right height"}
{"s": "MaxHeapify algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 1, "concept": "height current right height"}
{"s": "Union algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 1, "concept": "height current right height"}
{"s": "Intersection algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 1, "concept": "height current right height"}
{"s": "algorithm", "p": "Is-a-Prerequisite-of", "o": "data structure", "id": 2, "concept": "end inword end end"}
{"s": "algorithm", "p": "Used-for", "o": "problem solving", "id": 2, "concept": "end inword end end"}
{"s": "algorithm", "p": "Evaluate-for", "o": "efficiency", "id": 2, "concept": "end inword end end"}
{"s": "algorithm", "p": "Compare", "o": "algorithm", "id": 2, "concept": "end inword end end"}
{"s": "Big O notation", "p": "Used-for", "o": "algorithm analysis", "id": 2, "concept": "end inword end end"}
{"s": "algorithm", "p": "Part-of", "o": "data structures and algorithms", "id": 2, "concept": "end inword end end"}
{"s": "recursive algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 2, "concept": "end inword end end"}
{"s": "sorting algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 2, "concept": "end inword end end"}
{"s": "logarithmic algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 2, "concept": "end inword end end"}
{"s": "quadratic algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 2, "concept": "end inword end end"}
{"s": "exponential algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 2, "concept": "end inword end end"}
{"s": "cubic algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 2, "concept": "end inword end end"}
{"s": "prototype algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 2, "concept": "end inword end end"}
{"s": "garbage collection algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 2, "concept": "end inword end end"}
{"s": "resizing algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 2, "concept": "end inword end end"}
{"s": "traversal algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 2, "concept": "end inword end end"}
{"s": "insertion algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 2, "concept": "end inword end end"}
{"s": "deletion algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 2, "concept": "end inword end end"}
{"s": "search algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 2, "concept": "end inword end end"}
{"s": "Union algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 2, "concept": "end inword end end"}
{"s": "Intersection algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 2, "concept": "end inword end end"}
{"s": "MinHeapify algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 2, "concept": "end inword end end"}
{"s": "MaxHeapify algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 2, "concept": "end inword end end"}
{"s": "Add algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 2, "concept": "end inword end end"}
{"s": "Remove algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 2, "concept": "end inword end end"}
{"s": "Contains algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 2, "concept": "end inword end end"}
{"s": "FindParent algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 2, "concept": "end inword end end"}
{"s": "FindNode algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 2, "concept": "end inword end end"}
{"s": "FindMin algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 2, "concept": "end inword end end"}
{"s": "FindMax algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 2, "concept": "end inword end end"}
{"s": "Preorder algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 2, "concept": "end inword end end"}
{"s": "Postorder algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 2, "concept": "end inword end end"}
{"s": "Inorder algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 2, "concept": "end inword end end"}
{"s": "BreadthFirst algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 2, "concept": "end inword end end"}
{"s": "algorithm design", "p": "Part-of", "o": "algorithm", "id": 2, "concept": "end inword end end"}
{"s": "algorithm analysis", "p": "Conjunction", "o": "growth", "id": 2, "concept": "end inword end end"}
{"s": "algorithm", "p": "Used-for", "o": "sorting", "id": 2, "concept": "end inword end end"}
{"s": "algorithm", "p": "Used-for", "o": "string operations", "id": 2, "concept": "end inword end end"}
{"s": "algorithm", "p": "Used-for", "o": "tree traversal", "id": 2, "concept": "end inword end end"}
{"s": "pseudocode", "p": "Used-for", "o": "algorithm design", "id": 2, "concept": "end inword end end"}
{"s": "test cases", "p": "Used-for", "o": "algorithm verification", "id": 2, "concept": "end inword end end"}
{"s": "pre-conditions", "p": "Is-a-Prerequisite-of", "o": "algorithm", "id": 2, "concept": "end inword end end"}
{"s": "linked list", "p": "Part-of", "o": "data structure", "id": 2, "concept": "end inword end end"}
{"s": "doubly linked list", "p": "Hyponym-Of", "o": "linked list", "id": 2, "concept": "end inword end end"}
{"s": "singly linked list", "p": "Hyponym-Of", "o": "linked list", "id": 2, "concept": "end inword end end"}
{"s": "binary search tree", "p": "Part-of", "o": "data structure", "id": 2, "concept": "end inword end end"}
{"s": "heap", "p": "Part-of", "o": "data structure", "id": 2, "concept": "end inword end end"}
{"s": "min-heap", "p": "Hyponym-Of", "o": "heap", "id": 2, "concept": "end inword end end"}
{"s": "max-heap", "p": "Hyponym-Of", "o": "heap", "id": 2, "concept": "end inword end end"}
{"s": "set", "p": "Part-of", "o": "data structure", "id": 2, "concept": "end inword end end"}
{"s": "algorithm", "p": "Compare", "o": "algorithm", "id": 2, "concept": "end inword end end"}
{"s": "algorithm", "p": "Evaluate-for", "o": "efficiency", "id": 2, "concept": "end inword end end"}
{"s": "algorithm", "p": "Is-a-Prerequisite-of", "o": "data structure", "id": 2, "concept": "end inword end end"}
{"s": "algorithm", "p": "Used-for", "o": "problem solving", "id": 2, "concept": "end inword end end"}
{"s": "algorithm", "p": "Is-a-Prerequisite-of", "o": "data structure", "id": 3, "concept": "method return address popped"}
{"s": "algorithm", "p": "Used-for", "o": "problem solving", "id": 3, "concept": "method return address popped"}
{"s": "algorithm", "p": "Evaluate-for", "o": "efficiency", "id": 3, "concept": "method return address popped"}
{"s": "algorithm", "p": "Part-of", "o": "data structures and algorithms", "id": 3, "concept": "method return address popped"}
{"s": "Big O notation", "p": "Used-for", "o": "algorithm analysis", "id": 3, "concept": "method return address popped"}
{"s": "logarithmic algorithm", "p": "Compare", "o": "quadratic algorithm", "id": 3, "concept": "method return address popped"}
{"s": "algorithm", "p": "Part-of", "o": "chapter", "id": 3, "concept": "method return address popped"}
{"s": "algorithm", "p": "Part-of", "o": "book", "id": 3, "concept": "method return address popped"}
{"s": "algorithm", "p": "Evaluate-for", "o": "performance", "id": 3, "concept": "method return address popped"}
{"s": "pseudocode", "p": "Used-for", "o": "algorithm design", "id": 3, "concept": "method return address popped"}
{"s": "recursive algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 3, "concept": "method return address popped"}
{"s": "Add algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 3, "concept": "method return address popped"}
{"s": "Insert algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 3, "concept": "method return address popped"}
{"s": "InsertNode algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 3, "concept": "method return address popped"}
{"s": "FindParent algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 3, "concept": "method return address popped"}
{"s": "FindNode algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 3, "concept": "method return address popped"}
{"s": "FindMin algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 3, "concept": "method return address popped"}
{"s": "FindMax algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 3, "concept": "method return address popped"}
{"s": "Preorder algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 3, "concept": "method return address popped"}
{"s": "Postorder algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 3, "concept": "method return address popped"}
{"s": "Inorder algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 3, "concept": "method return address popped"}
{"s": "BreadthFirst algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 3, "concept": "method return address popped"}
{"s": "MinHeapify algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 3, "concept": "method return address popped"}
{"s": "MaxHeapify algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 3, "concept": "method return address popped"}
{"s": "Union algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 3, "concept": "method return address popped"}
{"s": "Intersection algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 3, "concept": "method return address popped"}
{"s": "algorithm design", "p": "Part-of", "o": "algorithm", "id": 3, "concept": "method return address popped"}
{"s": "algorithm implementation", "p": "Part-of", "o": "algorithm", "id": 3, "concept": "method return address popped"}
{"s": "algorithm analysis", "p": "Part-of", "o": "algorithm", "id": 3, "concept": "method return address popped"}
{"s": "algorithm", "p": "Conjunction", "o": "data structures", "id": 3, "concept": "method return address popped"}
{"s": "sorting algorithms", "p": "Hyponym-Of", "o": "algorithm", "id": 3, "concept": "method return address popped"}
{"s": "garbage collection algorithms", "p": "Hyponym-Of", "o": "algorithm", "id": 3, "concept": "method return address popped"}
{"s": "resizing algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 3, "concept": "method return address popped"}
{"s": "heap insertion algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 3, "concept": "method return address popped"}
{"s": "deletion algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 3, "concept": "method return address popped"}
{"s": "search algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 3, "concept": "method return address popped"}
{"s": "Pre-condition", "p": "Part-of", "o": "algorithm", "id": 3, "concept": "method return address popped"}
{"s": "Post-condition", "p": "Part-of", "o": "algorithm", "id": 3, "concept": "method return address popped"}
{"s": "cubic algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 3, "concept": "method return address popped"}
{"s": "exponential algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 3, "concept": "method return address popped"}
{"s": "Add algorithm", "p": "Compare", "o": "Remove algorithm", "id": 3, "concept": "method return address popped"}
{"s": "Add algorithm", "p": "Compare", "o": "Contains algorithm", "id": 3, "concept": "method return address popped"}
{"s": "Add algorithm", "p": "Compare", "o": "Traverse algorithm", "id": 3, "concept": "method return address popped"}
{"s": "Add algorithm", "p": "Compare", "o": "ReverseTraversal algorithm", "id": 3, "concept": "method return address popped"}
{"s": "Add algorithm", "p": "Compare", "o": "Insert algorithm", "id": 3, "concept": "method return address popped"}
{"s": "Add algorithm", "p": "Compare", "o": "InsertNode algorithm", "id": 3, "concept": "method return address popped"}
{"s": "Add algorithm", "p": "Compare", "o": "FindParent algorithm", "id": 3, "concept": "method return address popped"}
{"s": "Add algorithm", "p": "Compare", "o": "FindNode algorithm", "id": 3, "concept": "method return address popped"}
{"s": "Add algorithm", "p": "Compare", "o": "FindMin algorithm", "id": 3, "concept": "method return address popped"}
{"s": "Add algorithm", "p": "Compare", "o": "FindMax algorithm", "id": 3, "concept": "method return address popped"}
{"s": "Add algorithm", "p": "Compare", "o": "Preorder algorithm", "id": 3, "concept": "method return address popped"}
{"s": "Add algorithm", "p": "Compare", "o": "Postorder algorithm", "id": 3, "concept": "method return address popped"}
{"s": "Add algorithm", "p": "Compare", "o": "Inorder algorithm", "id": 3, "concept": "method return address popped"}
{"s": "Add algorithm", "p": "Compare", "o": "BreadthFirst algorithm", "id": 3, "concept": "method return address popped"}
{"s": "Add algorithm", "p": "Compare", "o": "MinHeapify algorithm", "id": 3, "concept": "method return address popped"}
{"s": "Add algorithm", "p": "Compare", "o": "MaxHeapify algorithm", "id": 3, "concept": "method return address popped"}
{"s": "Add algorithm", "p": "Compare", "o": "Union algorithm", "id": 3, "concept": "method return address popped"}
{"s": "Add algorithm", "p": "Compare", "o": "Intersection algorithm", "id": 3, "concept": "method return address popped"}
{"s": "algorithm", "p": "Is-a-Prerequisite-of", "o": "data structure", "id": 4, "concept": "left enqueue"}
{"s": "algorithm", "p": "Used-for", "o": "problem solving", "id": 4, "concept": "left enqueue"}
{"s": "algorithm", "p": "Evaluate-for", "o": "efficiency", "id": 4, "concept": "left enqueue"}
{"s": "Big O notation", "p": "Used-for", "o": "algorithm analysis", "id": 4, "concept": "left enqueue"}
{"s": "logarithmic algorithm", "p": "Compare", "o": "quadratic algorithm", "id": 4, "concept": "left enqueue"}
{"s": "algorithm design", "p": "Part-of", "o": "algorithm", "id": 4, "concept": "left enqueue"}
{"s": "algorithm", "p": "Part-of", "o": "pre-conditions", "id": 4, "concept": "left enqueue"}
{"s": "algorithm", "p": "Part-of", "o": "post-conditions", "id": 4, "concept": "left enqueue"}
{"s": "algorithm", "p": "Part-of", "o": "algorithm signature", "id": 4, "concept": "left enqueue"}
{"s": "algorithm", "p": "Part-of", "o": "parameters", "id": 4, "concept": "left enqueue"}
{"s": "recursive algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 4, "concept": "left enqueue"}
{"s": "sorting algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 4, "concept": "left enqueue"}
{"s": "garbage collection algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 4, "concept": "left enqueue"}
{"s": "Add algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 4, "concept": "left enqueue"}
{"s": "Contains algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 4, "concept": "left enqueue"}
{"s": "Remove algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 4, "concept": "left enqueue"}
{"s": "Traverse algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 4, "concept": "left enqueue"}
{"s": "ReverseTraversal algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 4, "concept": "left enqueue"}
{"s": "Insert algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 4, "concept": "left enqueue"}
{"s": "InsertNode algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 4, "concept": "left enqueue"}
{"s": "FindParent algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 4, "concept": "left enqueue"}
{"s": "FindNode algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 4, "concept": "left enqueue"}
{"s": "FindMin algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 4, "concept": "left enqueue"}
{"s": "FindMax algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 4, "concept": "left enqueue"}
{"s": "Preorder algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 4, "concept": "left enqueue"}
{"s": "Postorder algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 4, "concept": "left enqueue"}
{"s": "Inorder algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 4, "concept": "left enqueue"}
{"s": "BreadthFirst algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 4, "concept": "left enqueue"}
{"s": "MinHeapify algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 4, "concept": "left enqueue"}
{"s": "MaxHeapify algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 4, "concept": "left enqueue"}
{"s": "Union algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 4, "concept": "left enqueue"}
{"s": "Intersection algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 4, "concept": "left enqueue"}
{"s": "algorithm", "p": "Conjunction", "o": "data structures", "id": 4, "concept": "left enqueue"}
{"s": "algorithm", "p": "Part-of", "o": "test cases", "id": 4, "concept": "left enqueue"}
{"s": "pseudocode", "p": "Used-for", "o": "algorithm design", "id": 4, "concept": "left enqueue"}
{"s": "algorithm", "p": "Is-a-Prerequisite-of", "o": "parameters", "id": 4, "concept": "left enqueue"}
{"s": "algorithm", "p": "Part-of", "o": "loops", "id": 4, "concept": "left enqueue"}
{"s": "asymptotic run time", "p": "Used-for", "o": "algorithm efficiency evaluation", "id": 4, "concept": "left enqueue"}
{"s": "quadratic algorithm", "p": "Compare", "o": "logarithmic algorithm", "id": 4, "concept": "left enqueue"}
{"s": "algorithm", "p": "Part-of", "o": "resizing algorithms", "id": 4, "concept": "left enqueue"}
{"s": "index", "p": "Part-of", "o": "array", "id": 0, "concept": "index index"}
{"s": "index", "p": "Used-for", "o": "FindIndex", "id": 0, "concept": "index index"}
{"s": "index", "p": "Compare", "o": "top-of-stack index", "id": 0, "concept": "index index"}
{"s": "queues", "p": "Part-of", "o": "array", "id": 0, "concept": "index index"}
{"s": "GetQueueIndex", "p": "Used-for", "o": "queues", "id": 0, "concept": "index index"}
{"s": "indexOfKey", "p": "Part-of", "o": "item", "id": 0, "concept": "index index"}
{"s": "item", "p": "Part-of", "o": "queues", "id": 0, "concept": "index index"}
{"s": "index", "p": "Used-for", "o": "increment", "id": 0, "concept": "index index"}
{"s": "index", "p": "Part-of", "o": "array", "id": 1, "concept": "false return true"}
{"s": "index", "p": "Used-for", "o": "memory management", "id": 1, "concept": "false return true"}
{"s": "index", "p": "Compare", "o": "top-of-stack index", "id": 1, "concept": "false return true"}
{"s": "top-of-stack index", "p": "Compare", "o": "index", "id": 1, "concept": "false return true"}
{"s": "index", "p": "Part-of", "o": "array", "id": 2, "concept": "10 11"}
{"s": "index", "p": "Used-for", "o": "memory management", "id": 2, "concept": "10 11"}
{"s": "index", "p": "Compare", "o": "top-of-stack index", "id": 2, "concept": "10 11"}
{"s": "array index", "p": "Part-of", "o": "array", "id": 2, "concept": "10 11"}
{"s": "GetQueueIndex", "p": "Used-for", "o": "queues", "id": 2, "concept": "10 11"}
{"s": "index", "p": "Part-of", "o": "array", "id": 3, "concept": "order post list sorted"}
{"s": "index", "p": "Used-for", "o": "memory management", "id": 3, "concept": "order post list sorted"}
{"s": "index", "p": "Part-of", "o": "array", "id": 4, "concept": "return keyword cause"}
{"s": "index", "p": "Used-for", "o": "memory management", "id": 4, "concept": "return keyword cause"}
{"s": "index", "p": "Compare", "o": "top-of-stack index", "id": 4, "concept": "return keyword cause"}
{"s": "array", "p": "Part-of", "o": "data structure", "id": 4, "concept": "return keyword cause"}
{"s": "run time complexity analysis", "p": "Is-a-Prerequisite-of", "o": "oh notation extensively", "id": 0, "concept": "oh notation extensively"}
{"s": "oh notation extensively", "p": "Used-for", "o": "Rotation", "id": 0, "concept": "oh notation extensively"}
{"s": "Big O notation", "p": "Is-a-Prerequisite-of", "o": "Runtime complexity analysis", "id": 1, "concept": "make thing complex follow"}
{"s": "Big O notation", "p": "Used-for", "o": "Algorithm analysis", "id": 1, "concept": "make thing complex follow"}
{"s": "Rotation", "p": "Part-of", "o": "Algorithm", "id": 1, "concept": "make thing complex follow"}
{"s": "run time complexity analysis", "p": "Used-for", "o": "oh notation extensively", "id": 2, "concept": "false return false"}
{"s": "Run time complexity analysis", "p": "Used-for", "o": "oh notation extensively", "id": 3, "concept": "chapter introduction"}
{"s": "Run time complexity analysis", "p": "Used-for", "o": "Oh notation extensively", "id": 4, "concept": "list index item end"}
{"s": "Oh notation extensively", "p": "Is-a-Prerequisite-of", "o": "Algorithm analysis", "id": 4, "concept": "list index item end"}
{"s": "selecting correct sorting algorithm", "p": "Used-for", "o": "efficiency", "id": 0, "concept": "selecting correct sorting"}
{"s": "sorting algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 0, "concept": "selecting correct sorting"}
{"s": "efficiency", "p": "Evaluate-for", "o": "sorting algorithm", "id": 0, "concept": "selecting correct sorting"}
{"s": "selecting correct sorting algorithm", "p": "Evaluate-for", "o": "efficiency", "id": 1, "concept": "false case"}
{"s": "sorting algorithm", "p": "Part-of", "o": "sorting", "id": 1, "concept": "false case"}
{"s": "selecting correct sorting algorithm", "p": "Evaluate-for", "o": "efficiency", "id": 2, "concept": "figure 11"}
{"s": "sorting algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 2, "concept": "figure 11"}
{"s": "selecting correct sorting algorithm", "p": "Is-a-Prerequisite-of", "o": "efficiency", "id": 3, "concept": "set e\ufb03ciently implemented using"}
{"s": "sorting algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 3, "concept": "set e\ufb03ciently implemented using"}
{"s": "deletion algorithm", "p": "Is-a-Prerequisite-of", "o": "insertion algorithm", "id": 0, "concept": "deletion algorithm remove"}
{"s": "deletion algorithm", "p": "Compare", "o": "insertion algorithm", "id": 0, "concept": "deletion algorithm remove"}
{"s": "right rotation algorithm", "p": "Conjunction", "o": "left rotation algorithm", "id": 0, "concept": "deletion algorithm remove"}
{"s": "deletion algorithm", "p": "Is-a-Prerequisite-of", "o": "insertion algorithm", "id": 1, "concept": "value parent greater"}
{"s": "deletion algorithm", "p": "Compare", "o": "insertion algorithm", "id": 1, "concept": "value parent greater"}
{"s": "right rotation algorithm", "p": "Conjunction", "o": "left rotation algorithm", "id": 1, "concept": "value parent greater"}
{"s": "deletion algorithm", "p": "Part-of", "o": "algorithms", "id": 1, "concept": "value parent greater"}
{"s": "deletion algorithm", "p": "Compare", "o": "insertion algorithm", "id": 2, "concept": "oh notation big"}
{"s": "deletion algorithm", "p": "Part-of", "o": "algorithms", "id": 2, "concept": "oh notation big"}
{"s": "insertion algorithm", "p": "Conjunction", "o": "deletion algorithm", "id": 2, "concept": "oh notation big"}
{"s": "right rotation algorithm", "p": "Compare", "o": "left rotation algorithm", "id": 2, "concept": "oh notation big"}
{"s": "deletion algorithm", "p": "Compare", "o": "insertion algorithm", "id": 3, "concept": "optimisation compiler"}
{"s": "deletion algorithm", "p": "Part-of", "o": "algorithms", "id": 3, "concept": "optimisation compiler"}
{"s": "insertion algorithm", "p": "Conjunction", "o": "deletion algorithm", "id": 3, "concept": "optimisation compiler"}
{"s": "right rotation algorithm", "p": "Compare", "o": "left rotation algorithm", "id": 3, "concept": "optimisation compiler"}
{"s": "deletion algorithm", "p": "Evaluate-for", "o": "cost", "id": 3, "concept": "optimisation compiler"}
{"s": "deletion algorithm", "p": "Compare", "o": "insertion algorithm", "id": 4, "concept": "performs left rotation"}
{"s": "deletion algorithm", "p": "Part-of", "o": "algorithms", "id": 4, "concept": "performs left rotation"}
{"s": "insertion algorithm", "p": "Conjunction", "o": "deletion algorithm", "id": 4, "concept": "performs left rotation"}
{"s": "right rotation algorithm", "p": "Compare", "o": "left rotation algorithm", "id": 4, "concept": "performs left rotation"}
{"s": "deletion algorithm", "p": "Used-for", "o": "count", "id": 4, "concept": "performs left rotation"}
{"s": "insertion algorithm", "p": "Used-for", "o": "count", "id": 4, "concept": "performs left rotation"}
{"s": "Sorting algorithm", "p": "Is-a-Prerequisite-of", "o": "Demonstrating sorting", "id": 0, "concept": "right sorting"}
{"s": "Sorting algorithm", "p": "Evaluate-for", "o": "Efficiency", "id": 0, "concept": "right sorting"}
{"s": "Selection sort", "p": "Hyponym-Of", "o": "Sorting algorithm", "id": 0, "concept": "right sorting"}
{"s": "Merge sort", "p": "Hyponym-Of", "o": "Sorting algorithm", "id": 0, "concept": "right sorting"}
{"s": "Quick sort", "p": "Hyponym-Of", "o": "Sorting algorithm", "id": 0, "concept": "right sorting"}
{"s": "Bubble sort", "p": "Hyponym-Of", "o": "Sorting algorithm", "id": 0, "concept": "right sorting"}
{"s": "Insertion sort", "p": "Hyponym-Of", "o": "Sorting algorithm", "id": 0, "concept": "right sorting"}
{"s": "Efficiency", "p": "Compare", "o": "Sorting algorithm", "id": 0, "concept": "right sorting"}
{"s": "Sorting algorithm", "p": "Used-for", "o": "right sorting", "id": 1, "concept": "yield root value return"}
{"s": "Sorting algorithm", "p": "Evaluate-for", "o": "efficiency", "id": 1, "concept": "yield root value return"}
{"s": "Efficiency", "p": "Compare", "o": "Sorting algorithm", "id": 1, "concept": "yield root value return"}
{"s": "Sorting algorithm", "p": "Is-a-Prerequisite-of", "o": "demonstration", "id": 2, "concept": "factorial number"}
{"s": "Sorting algorithm", "p": "Evaluate-for", "o": "efficiency", "id": 2, "concept": "factorial number"}
{"s": "algorithm", "p": "Part-of", "o": "Sorting algorithm", "id": 2, "concept": "factorial number"}
{"s": "Sorting algorithms", "p": "Compare", "o": "Efficiency", "id": 3, "concept": "return list return list"}
{"s": "Sorting algorithm", "p": "Is-a-Prerequisite-of", "o": "Efficiency", "id": 4, "concept": "inword end end"}
{"s": "Sorting algorithm", "p": "Used-for", "o": "demonstration", "id": 4, "concept": "inword end end"}
{"s": "Selection sort", "p": "Hyponym-Of", "o": "Sorting algorithm", "id": 4, "concept": "inword end end"}
{"s": "Merge sort", "p": "Hyponym-Of", "o": "Sorting algorithm", "id": 4, "concept": "inword end end"}
{"s": "Quick sort", "p": "Hyponym-Of", "o": "Sorting algorithm", "id": 4, "concept": "inword end end"}
{"s": "Bubble sort", "p": "Hyponym-Of", "o": "Sorting algorithm", "id": 4, "concept": "inword end end"}
{"s": "Sorting algorithm", "p": "Compare", "o": "Efficiency", "id": 4, "concept": "inword end end"}
{"s": "index", "p": "Part-of", "o": "Left", "id": 0, "concept": "parent index index left"}
{"s": "index", "p": "Compare", "o": "left", "id": 0, "concept": "parent index index left"}
{"s": "parent", "p": "Part-of", "o": "index", "id": 0, "concept": "parent index index left"}
{"s": "index", "p": "Conjunction", "o": "left", "id": 0, "concept": "parent index index left"}
{"s": "index", "p": "Part-of", "o": "Part I", "id": 1, "concept": "sort algorithm"}
{"s": "index", "p": "Part-of", "o": "Part II", "id": 1, "concept": "sort algorithm"}
{"s": "left", "p": "Conjunction", "o": "index", "id": 1, "concept": "sort algorithm"}
{"s": "parent", "p": "Part-of", "o": "Part I", "id": 1, "concept": "sort algorithm"}
{"s": "index", "p": "Part-of", "o": "Part I", "id": 2, "concept": "wanted determine thousand"}
{"s": "index", "p": "Part-of", "o": "Part II", "id": 2, "concept": "wanted determine thousand"}
{"s": "left", "p": "Conjunction", "o": "index", "id": 2, "concept": "wanted determine thousand"}
{"s": "parent", "p": "Part-of", "o": "Part I", "id": 2, "concept": "wanted determine thousand"}
{"s": "index", "p": "Part-of", "o": "Part I", "id": 3, "concept": "sort quick sort"}
{"s": "index", "p": "Part-of", "o": "Part II", "id": 3, "concept": "sort quick sort"}
{"s": "left", "p": "Conjunction", "o": "index", "id": 3, "concept": "sort quick sort"}
{"s": "parent", "p": "Part-of", "o": "Part I", "id": 3, "concept": "sort quick sort"}
{"s": "Binary Search Tree", "p": "Is-a-Prerequisite-of", "o": "AVL tree", "id": 0, "concept": "search tree binary search"}
{"s": "Binary Search Tree", "p": "Compare", "o": "AVL tree", "id": 0, "concept": "search tree binary search"}
{"s": "AVL tree", "p": "Hyponym-Of", "o": "Binary Search Tree", "id": 0, "concept": "search tree binary search"}
{"s": "Binary Search Tree", "p": "Part-of", "o": "search tree", "id": 0, "concept": "search tree binary search"}
{"s": "Binary Search Tree", "p": "Is-a-Prerequisite-of", "o": "AVL tree", "id": 2, "concept": "binary search tree example"}
{"s": "Binary Search Tree", "p": "Compare", "o": "AVL tree", "id": 2, "concept": "binary search tree example"}
{"s": "Binary Search", "p": "Part-of", "o": "Binary Search Tree", "id": 2, "concept": "binary search tree example"}
{"s": "AVL tree", "p": "Hyponym-Of", "o": "Binary Search Tree", "id": 2, "concept": "binary search tree example"}
{"s": "Binary Search Tree", "p": "Part-of", "o": "search tree", "id": 2, "concept": "binary search tree example"}
{"s": "Binary Search Tree", "p": "Is-a-Prerequisite-of", "o": "AVL tree", "id": 4, "concept": "pre root root node"}
{"s": "Binary Search Tree", "p": "Compare", "o": "AVL tree", "id": 4, "concept": "pre root root node"}
{"s": "Binary Search Tree", "p": "Part-of", "o": "search tree", "id": 4, "concept": "pre root root node"}
{"s": "AVL tree", "p": "Hyponym-Of", "o": "Binary Search Tree", "id": 4, "concept": "pre root root node"}
{"s": "Binary Search", "p": "Used-for", "o": "Binary Search Tree", "id": 4, "concept": "pre root root node"}
{"s": "parent", "p": "Compare", "o": "children", "id": 0, "concept": "parent greater"}
{"s": "parent", "p": "Compare", "o": "children", "id": 1, "concept": "value return root"}
{"s": "GreatestCommonDenominator", "p": "Used-for", "o": "recursive", "id": 1, "concept": "value return root"}
{"s": "list", "p": "Part-of", "o": "GreatestCommonDenominator", "id": 1, "concept": "value return root"}
{"s": "parent", "p": "Compare", "o": "children", "id": 2, "concept": "number consists digit base"}
{"s": "parent", "p": "Compare", "o": "children", "id": 3, "concept": "item deque contain"}
{"s": "parent", "p": "Compare", "o": "children", "id": 4, "concept": "nodetoremove left nodetoremove value"}
{"s": "Sorting algorithm", "p": "Hyponym-Of", "o": "Algorithm", "id": 0, "concept": "sorting algorithm"}
{"s": "Merge sort", "p": "Is-a-Prerequisite-of", "o": "Sorting algorithm", "id": 0, "concept": "sorting algorithm"}
{"s": "Quick sort", "p": "Is-a-Prerequisite-of", "o": "Sorting algorithm", "id": 0, "concept": "sorting algorithm"}
{"s": "Insertion sort", "p": "Is-a-Prerequisite-of", "o": "Sorting algorithm", "id": 0, "concept": "sorting algorithm"}
{"s": "Radix sort", "p": "Is-a-Prerequisite-of", "o": "Sorting algorithm", "id": 0, "concept": "sorting algorithm"}
{"s": "Algorithm", "p": "Part-of", "o": "Data Structures and Algorithms", "id": 0, "concept": "sorting algorithm"}
{"s": "Algorithm", "p": "Used-for", "o": "Problem solving", "id": 0, "concept": "sorting algorithm"}
{"s": "Logarithmic algorithm", "p": "Compare", "o": "Quadratic algorithm", "id": 0, "concept": "sorting algorithm"}
{"s": "Algorithm", "p": "Evaluate-for", "o": "Efficiency", "id": 0, "concept": "sorting algorithm"}
{"s": "Cubic algorithm", "p": "Conjunction", "o": "Exponential algorithm", "id": 0, "concept": "sorting algorithm"}
{"s": "Algorithm design", "p": "Is-a-Prerequisite-of", "o": "Algorithm", "id": 0, "concept": "sorting algorithm"}
{"s": "Algorithm", "p": "Part-of", "o": "Algorithm design", "id": 0, "concept": "sorting algorithm"}
{"s": "Algorithm", "p": "Used-for", "o": "Node discovery", "id": 0, "concept": "sorting algorithm"}
{"s": "Garbage collection algorithm", "p": "Used-for", "o": "Memory management", "id": 0, "concept": "sorting algorithm"}
{"s": "Pre-condition", "p": "Part-of", "o": "Algorithm", "id": 0, "concept": "sorting algorithm"}
{"s": "Post-condition", "p": "Part-of", "o": "Algorithm", "id": 0, "concept": "sorting algorithm"}
{"s": "Algorithm", "p": "Evaluate-for", "o": "Effectiveness", "id": 0, "concept": "sorting algorithm"}
{"s": "Data structure", "p": "Conjunction", "o": "Algorithm", "id": 0, "concept": "sorting algorithm"}
{"s": "Linked list", "p": "Part-of", "o": "Data structure", "id": 0, "concept": "sorting algorithm"}
{"s": "Algorithm", "p": "Used-for", "o": "Linked list", "id": 0, "concept": "sorting algorithm"}
{"s": "Doubly linked list", "p": "Part-of", "o": "Data structure", "id": 0, "concept": "sorting algorithm"}
{"s": "Resizing algorithm", "p": "Used-for", "o": "Array", "id": 0, "concept": "sorting algorithm"}
{"s": "Insertion algorithm", "p": "Part-of", "o": "Algorithm", "id": 0, "concept": "sorting algorithm"}
{"s": "Recursive InsertNode algorithm", "p": "Part-of", "o": "Insertion algorithm", "id": 0, "concept": "sorting algorithm"}
{"s": "FindNode algorithm", "p": "Part-of", "o": "Algorithm", "id": 0, "concept": "sorting algorithm"}
{"s": "Contains algorithm", "p": "Part-of", "o": "Algorithm", "id": 0, "concept": "sorting algorithm"}
{"s": "FindMin algorithm", "p": "Part-of", "o": "Algorithm", "id": 0, "concept": "sorting algorithm"}
{"s": "FindMax algorithm", "p": "Part-of", "o": "Algorithm", "id": 0, "concept": "sorting algorithm"}
{"s": "Algorithm", "p": "Used-for", "o": "Recursive data structure", "id": 0, "concept": "sorting algorithm"}
{"s": "Heap order", "p": "Part-of", "o": "Heap insertion algorithm", "id": 0, "concept": "sorting algorithm"}
{"s": "Deletion algorithm", "p": "Part-of", "o": "Algorithm", "id": 0, "concept": "sorting algorithm"}
{"s": "Search algorithm", "p": "Part-of", "o": "Algorithm", "id": 0, "concept": "sorting algorithm"}
{"s": "Min-heap", "p": "Part-of", "o": "Data structure", "id": 0, "concept": "sorting algorithm"}
{"s": "Hashing algorithm", "p": "Part-of", "o": "Hash table", "id": 0, "concept": "sorting algorithm"}
{"s": "Set", "p": "Used-for", "o": "Algorithm", "id": 0, "concept": "sorting algorithm"}
{"s": "Resizing algorithm", "p": "Used-for", "o": "Deque", "id": 0, "concept": "sorting algorithm"}
{"s": "Garbage collection algorithm", "p": "Used-for", "o": "Memory management", "id": 0, "concept": "sorting algorithm"}
{"s": "Right rotation algorithm", "p": "Conjunction", "o": "Left rotation algorithm", "id": 0, "concept": "sorting algorithm"}
{"s": "Balancing algorithm", "p": "Part-of", "o": "Algorithm", "id": 0, "concept": "sorting algorithm"}
{"s": "Divide et impera", "p": "Part-of", "o": "Quick sort", "id": 0, "concept": "sorting algorithm"}
{"s": "Algorithm", "p": "Used-for", "o": "Queue", "id": 0, "concept": "sorting algorithm"}
{"s": "Algorithm", "p": "Evaluate-for", "o": "Efficiency", "id": 0, "concept": "sorting algorithm"}
{"s": "Algorithm", "p": "Used-for", "o": "Integer conversion", "id": 0, "concept": "sorting algorithm"}
{"s": "Algorithm", "p": "Used-for", "o": "List search", "id": 0, "concept": "sorting algorithm"}
{"s": "Searching algorithm", "p": "Used-for", "o": "Underlying data structure", "id": 0, "concept": "sorting algorithm"}
{"s": "Strip", "p": "Used-for", "o": "IsPalindrome algorithm", "id": 0, "concept": "sorting algorithm"}
{"s": "Sorting algorithm", "p": "Hyponym-Of", "o": "Algorithm", "id": 1, "concept": "list sorted value ascending"}
{"s": "Merge sort", "p": "Is-a-Prerequisite-of", "o": "Sorting algorithm", "id": 1, "concept": "list sorted value ascending"}
{"s": "Quick sort", "p": "Is-a-Prerequisite-of", "o": "Sorting algorithm", "id": 1, "concept": "list sorted value ascending"}
{"s": "Insertion sort", "p": "Is-a-Prerequisite-of", "o": "Sorting algorithm", "id": 1, "concept": "list sorted value ascending"}
{"s": "Radix sort", "p": "Is-a-Prerequisite-of", "o": "Sorting algorithm", "id": 1, "concept": "list sorted value ascending"}
{"s": "Algorithm", "p": "Used-for", "o": "Data structure", "id": 1, "concept": "list sorted value ascending"}
{"s": "Algorithm", "p": "Part-of", "o": "Data Structures and Algorithms", "id": 1, "concept": "list sorted value ascending"}
{"s": "Algorithm", "p": "Evaluate-for", "o": "Efficiency", "id": 1, "concept": "list sorted value ascending"}
{"s": "Logarithmic algorithm", "p": "Compare", "o": "Quadratic algorithm", "id": 1, "concept": "list sorted value ascending"}
{"s": "Cubic algorithm", "p": "Compare", "o": "Exponential algorithm", "id": 1, "concept": "list sorted value ascending"}
{"s": "Recursive algorithm", "p": "Is-a-Prerequisite-of", "o": "Algorithm", "id": 1, "concept": "list sorted value ascending"}
{"s": "Algorithm", "p": "Used-for", "o": "Linked list", "id": 1, "concept": "list sorted value ascending"}
{"s": "Resizing algorithm", "p": "Part-of", "o": "Data structure", "id": 1, "concept": "list sorted value ascending"}
{"s": "Algorithm", "p": "Part-of", "o": "Chapter", "id": 1, "concept": "list sorted value ascending"}
{"s": "Algorithm", "p": "Conjunction", "o": "Data structure", "id": 1, "concept": "list sorted value ascending"}
{"s": "Algorithm", "p": "Used-for", "o": "Heap", "id": 1, "concept": "list sorted value ascending"}
{"s": "Algorithm", "p": "Used-for", "o": "Set", "id": 1, "concept": "list sorted value ascending"}
{"s": "Algorithm", "p": "Used-for", "o": "Queue", "id": 1, "concept": "list sorted value ascending"}
{"s": "Algorithm", "p": "Used-for", "o": "Priority queue", "id": 1, "concept": "list sorted value ascending"}
{"s": "Algorithm", "p": "Used-for", "o": "Deque", "id": 1, "concept": "list sorted value ascending"}
{"s": "Garbage collection algorithm", "p": "Part-of", "o": "Algorithm", "id": 1, "concept": "list sorted value ascending"}
{"s": "Balancing algorithm", "p": "Part-of", "o": "AVL tree", "id": 1, "concept": "list sorted value ascending"}
{"s": "Algorithm", "p": "Used-for", "o": "String", "id": 1, "concept": "list sorted value ascending"}
{"s": "Algorithm", "p": "Used-for", "o": "Integer", "id": 1, "concept": "list sorted value ascending"}
{"s": "Algorithm", "p": "Used-for", "o": "Binary", "id": 1, "concept": "list sorted value ascending"}
{"s": "Algorithm", "p": "Used-for", "o": "List", "id": 1, "concept": "list sorted value ascending"}
{"s": "Probability search", "p": "Hyponym-Of", "o": "Searching algorithm", "id": 1, "concept": "list sorted value ascending"}
{"s": "Binary chop", "p": "Hyponym-Of", "o": "Searching algorithm", "id": 1, "concept": "list sorted value ascending"}
{"s": "Searching algorithm", "p": "Used-for", "o": "AVL tree", "id": 1, "concept": "list sorted value ascending"}
{"s": "Searching algorithm", "p": "Used-for", "o": "BST tree", "id": 1, "concept": "list sorted value ascending"}
{"s": "Palindrome detection algorithm", "p": "Hyponym-Of", "o": "Algorithm", "id": 1, "concept": "list sorted value ascending"}
{"s": "Strip", "p": "Used-for", "o": "IsPalindrome algorithm", "id": 1, "concept": "list sorted value ascending"}
{"s": "RepeatedWordCount algorithm", "p": "Part-of", "o": "Algorithm", "id": 1, "concept": "list sorted value ascending"}
{"s": "sorting algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 2, "concept": "return caller exhausted scenario"}
{"s": "Merge sort", "p": "Is-a-Prerequisite-of", "o": "sorting algorithm", "id": 2, "concept": "return caller exhausted scenario"}
{"s": "Quick sort", "p": "Is-a-Prerequisite-of", "o": "sorting algorithm", "id": 2, "concept": "return caller exhausted scenario"}
{"s": "Insertion sort", "p": "Is-a-Prerequisite-of", "o": "sorting algorithm", "id": 2, "concept": "return caller exhausted scenario"}
{"s": "Radix sort", "p": "Is-a-Prerequisite-of", "o": "sorting algorithm", "id": 2, "concept": "return caller exhausted scenario"}
{"s": "algorithm", "p": "Used-for", "o": "data structure", "id": 2, "concept": "return caller exhausted scenario"}
{"s": "algorithm", "p": "Part-of", "o": "Data Structures and Algorithms", "id": 2, "concept": "return caller exhausted scenario"}
{"s": "algorithm", "p": "Evaluate-for", "o": "efficiency", "id": 2, "concept": "return caller exhausted scenario"}
{"s": "logarithmic algorithm", "p": "Compare", "o": "quadratic algorithm", "id": 2, "concept": "return caller exhausted scenario"}
{"s": "recursive algorithm", "p": "Is-a-Prerequisite-of", "o": "algorithm", "id": 2, "concept": "return caller exhausted scenario"}
{"s": "algorithm", "p": "Part-of", "o": "chapter", "id": 2, "concept": "return caller exhausted scenario"}
{"s": "algorithm", "p": "Used-for", "o": "linked list", "id": 2, "concept": "return caller exhausted scenario"}
{"s": "algorithm", "p": "Used-for", "o": "doubly linked list", "id": 2, "concept": "return caller exhausted scenario"}
{"s": "algorithm", "p": "Used-for", "o": "heap", "id": 2, "concept": "return caller exhausted scenario"}
{"s": "algorithm", "p": "Used-for", "o": "set", "id": 2, "concept": "return caller exhausted scenario"}
{"s": "algorithm", "p": "Used-for", "o": "queue", "id": 2, "concept": "return caller exhausted scenario"}
{"s": "algorithm", "p": "Used-for", "o": "priority queue", "id": 2, "concept": "return caller exhausted scenario"}
{"s": "algorithm", "p": "Used-for", "o": "deque", "id": 2, "concept": "return caller exhausted scenario"}
{"s": "algorithm", "p": "Used-for", "o": "AVL tree", "id": 2, "concept": "return caller exhausted scenario"}
{"s": "algorithm", "p": "Used-for", "o": "BST", "id": 2, "concept": "return caller exhausted scenario"}
{"s": "algorithm", "p": "Used-for", "o": "hash table", "id": 2, "concept": "return caller exhausted scenario"}
{"s": "algorithm", "p": "Used-for", "o": "string", "id": 2, "concept": "return caller exhausted scenario"}
{"s": "algorithm", "p": "Conjunction", "o": "data structures", "id": 2, "concept": "return caller exhausted scenario"}
{"s": "resizing algorithm", "p": "Part-of", "o": "algorithm", "id": 2, "concept": "return caller exhausted scenario"}
{"s": "garbage collection algorithm", "p": "Part-of", "o": "algorithm", "id": 2, "concept": "return caller exhausted scenario"}
{"s": "balancing algorithm", "p": "Part-of", "o": "algorithm", "id": 2, "concept": "return caller exhausted scenario"}
{"s": "generic sorting algorithm", "p": "Hyponym-Of", "o": "sorting algorithm", "id": 2, "concept": "return caller exhausted scenario"}
{"s": "algorithm", "p": "Used-for", "o": "list", "id": 2, "concept": "return caller exhausted scenario"}
{"s": "algorithm", "p": "Used-for", "o": "array", "id": 2, "concept": "return caller exhausted scenario"}
{"s": "probability search", "p": "Hyponym-Of", "o": "searching algorithm", "id": 2, "concept": "return caller exhausted scenario"}
{"s": "binary chop", "p": "Hyponym-Of", "o": "searching algorithm", "id": 2, "concept": "return caller exhausted scenario"}
{"s": "Strip", "p": "Part-of", "o": "IsPalindrome algorithm", "id": 2, "concept": "return caller exhausted scenario"}
{"s": "sorting algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 3, "concept": "value yield root"}
{"s": "Merge sort", "p": "Is-a-Prerequisite-of", "o": "sorting algorithm", "id": 3, "concept": "value yield root"}
{"s": "Quick sort", "p": "Is-a-Prerequisite-of", "o": "sorting algorithm", "id": 3, "concept": "value yield root"}
{"s": "Insertion sort", "p": "Is-a-Prerequisite-of", "o": "sorting algorithm", "id": 3, "concept": "value yield root"}
{"s": "Radix sort", "p": "Is-a-Prerequisite-of", "o": "sorting algorithm", "id": 3, "concept": "value yield root"}
{"s": "algorithm", "p": "Used-for", "o": "sorting", "id": 3, "concept": "value yield root"}
{"s": "algorithm", "p": "Part-of", "o": "data structures and algorithms", "id": 3, "concept": "value yield root"}
{"s": "algorithm", "p": "Evaluate-for", "o": "efficiency", "id": 3, "concept": "value yield root"}
{"s": "logarithmic algorithm", "p": "Compare", "o": "quadratic algorithm", "id": 3, "concept": "value yield root"}
{"s": "recursive algorithm", "p": "Is-a-Prerequisite-of", "o": "algorithm", "id": 3, "concept": "value yield root"}
{"s": "algorithm", "p": "Part-of", "o": "Data Structures and Algorithms project", "id": 3, "concept": "value yield root"}
{"s": "quadratic algorithm", "p": "Compare", "o": "logarithmic algorithm", "id": 3, "concept": "value yield root"}
{"s": "algorithm", "p": "Used-for", "o": "node discovery", "id": 3, "concept": "value yield root"}
{"s": "algorithm", "p": "Used-for", "o": "garbage collection", "id": 3, "concept": "value yield root"}
{"s": "resizing algorithm", "p": "Part-of", "o": "data structure", "id": 3, "concept": "value yield root"}
{"s": "insertion algorithm", "p": "Part-of", "o": "sorting algorithm", "id": 3, "concept": "value yield root"}
{"s": "deletion algorithm", "p": "Part-of", "o": "sorting algorithm", "id": 3, "concept": "value yield root"}
{"s": "Union algorithm", "p": "Part-of", "o": "set", "id": 3, "concept": "value yield root"}
{"s": "Intersection algorithm", "p": "Part-of", "o": "set", "id": 3, "concept": "value yield root"}
{"s": "hashing algorithm", "p": "Part-of", "o": "hash table", "id": 3, "concept": "value yield root"}
{"s": "algorithm", "p": "Used-for", "o": "heap insertion", "id": 3, "concept": "value yield root"}
{"s": "algorithm", "p": "Used-for", "o": "heap deletion", "id": 3, "concept": "value yield root"}
{"s": "algorithm", "p": "Used-for", "o": "heap search", "id": 3, "concept": "value yield root"}
{"s": "algorithm", "p": "Used-for", "o": "string operations", "id": 3, "concept": "value yield root"}
{"s": "algorithm", "p": "Used-for", "o": "palindrome detection", "id": 3, "concept": "value yield root"}
{"s": "algorithm", "p": "Used-for", "o": "word counting", "id": 3, "concept": "value yield root"}
{"s": "algorithm", "p": "Used-for", "o": "binary conversion", "id": 3, "concept": "value yield root"}
{"s": "algorithm", "p": "Used-for", "o": "factorial calculation", "id": 3, "concept": "value yield root"}
{"s": "algorithm", "p": "Used-for", "o": "prime number determination", "id": 3, "concept": "value yield root"}
{"s": "algorithm", "p": "Used-for", "o": "list search", "id": 3, "concept": "value yield root"}
{"s": "Probability search", "p": "Is-a-Prerequisite-of", "o": "searching algorithm", "id": 3, "concept": "value yield root"}
{"s": "algorithm", "p": "Used-for", "o": "data structure", "id": 3, "concept": "value yield root"}
{"s": "balancing algorithm", "p": "Part-of", "o": "AVL tree", "id": 3, "concept": "value yield root"}
{"s": "left rotation algorithm", "p": "Conjunction", "o": "right rotation algorithm", "id": 3, "concept": "value yield root"}
{"s": "double rotations", "p": "Part-of", "o": "balancing algorithm", "id": 3, "concept": "value yield root"}
{"s": "algorithm", "p": "Evaluate-for", "o": "minimised test cases", "id": 3, "concept": "value yield root"}
{"s": "String", "p": "Part-of", "o": "Data Structure", "id": 0, "concept": "word string"}
{"s": "String", "p": "Hyponym-Of", "o": "Data Type", "id": 0, "concept": "word string"}
{"s": "Algorithm", "p": "Used-for", "o": "String Manipulation", "id": 0, "concept": "word string"}
{"s": "Algorithm", "p": "Used-for", "o": "String Reversal", "id": 0, "concept": "word string"}
{"s": "Algorithm", "p": "Used-for", "o": "Palindrome Check", "id": 0, "concept": "word string"}
{"s": "Algorithm", "p": "Used-for", "o": "Sub-string Search", "id": 0, "concept": "word string"}
{"s": "String", "p": "Conjunction", "o": "Word", "id": 0, "concept": "word string"}
{"s": "Word", "p": "Part-of", "o": "String", "id": 0, "concept": "word string"}
{"s": "Algorithm", "p": "Compare", "o": "Algorithm", "id": 0, "concept": "word string"}
{"s": "Algorithm", "p": "Evaluate-for", "o": "Efficiency", "id": 0, "concept": "word string"}
{"s": "Sorting Algorithm", "p": "Part-of", "o": "Algorithm", "id": 0, "concept": "word string"}
{"s": "word", "p": "Part-of", "o": "String", "id": 2, "concept": "set figure 11 step"}
{"s": "String", "p": "Is-a-Prerequisite-of", "o": "String operations", "id": 2, "concept": "set figure 11 step"}
{"s": "String", "p": "Used-for", "o": "String algorithms", "id": 2, "concept": "set figure 11 step"}
{"s": "String", "p": "Compare", "o": "Word", "id": 2, "concept": "set figure 11 step"}
{"s": "Algorithms", "p": "Conjunction", "o": "Sorting", "id": 2, "concept": "set figure 11 step"}
{"s": "Algorithms", "p": "Conjunction", "o": "String operations", "id": 2, "concept": "set figure 11 step"}
{"s": "String", "p": "Part-of", "o": "Data structure", "id": 2, "concept": "set figure 11 step"}
{"s": "Algorithms", "p": "Used-for", "o": "Sorting", "id": 2, "concept": "set figure 11 step"}
{"s": "Algorithms", "p": "Used-for", "o": "String operations", "id": 2, "concept": "set figure 11 step"}
{"s": "Palindrome", "p": "Hyponym-Of", "o": "String", "id": 2, "concept": "set figure 11 step"}
{"s": "String", "p": "Part-of", "o": "Data Structure", "id": 3, "concept": "value ascending order post"}
{"s": "String", "p": "Hyponym-Of", "o": "Data Type", "id": 3, "concept": "value ascending order post"}
{"s": "Algorithm", "p": "Used-for", "o": "String", "id": 3, "concept": "value ascending order post"}
{"s": "String", "p": "Conjunction", "o": "Word", "id": 3, "concept": "value ascending order post"}
{"s": "Algorithm", "p": "Evaluate-for", "o": "String", "id": 3, "concept": "value ascending order post"}
{"s": "Palindrome", "p": "Is-a-Prerequisite-of", "o": "String", "id": 3, "concept": "value ascending order post"}
{"s": "Substring", "p": "Part-of", "o": "String", "id": 3, "concept": "value ascending order post"}
{"s": "String", "p": "Used-for", "o": "Algorithm", "id": 3, "concept": "value ascending order post"}
{"s": "Word", "p": "Part-of", "o": "String", "id": 3, "concept": "value ascending order post"}
{"s": "word", "p": "Part-of", "o": "String", "id": 4, "concept": "list increment"}
{"s": "String", "p": "Hyponym-Of", "o": "Data Structure", "id": 4, "concept": "list increment"}
{"s": "String", "p": "Used-for", "o": "String operations", "id": 4, "concept": "list increment"}
{"s": "algorithm", "p": "Used-for", "o": "String operations", "id": 4, "concept": "list increment"}
{"s": "algorithm", "p": "Compare", "o": "algorithm", "id": 4, "concept": "list increment"}
{"s": "String", "p": "Conjunction", "o": "word", "id": 4, "concept": "list increment"}
{"s": "algorithm", "p": "Part-of", "o": "chapter", "id": 4, "concept": "list increment"}
{"s": "sorting", "p": "Conjunction", "o": "string operations", "id": 4, "concept": "list increment"}
{"s": "palindrome", "p": "Part-of", "o": "String", "id": 4, "concept": "list increment"}
{"s": "sub-string", "p": "Part-of", "o": "String", "id": 4, "concept": "list increment"}
{"s": "heap", "p": "Part-of", "o": "array data structure", "id": 0, "concept": "heap value"}
{"s": "Min-Heapify algorithm", "p": "Compare", "o": "< operator", "id": 0, "concept": "heap value"}
{"s": "MaxHeapify algorithm", "p": "Compare", "o": "< operator", "id": 0, "concept": "heap value"}
{"s": "Min-heap", "p": "Compare", "o": "value", "id": 0, "concept": "heap value"}
{"s": "Max-heap", "p": "Compare", "o": "value", "id": 0, "concept": "heap value"}
{"s": "heap", "p": "Used-for", "o": "priority queues", "id": 0, "concept": "heap value"}
{"s": "heap value", "p": "Part-of", "o": "heap", "id": 0, "concept": "heap value"}
{"s": "value", "p": "Used-for", "o": "heap", "id": 0, "concept": "heap value"}
{"s": "value", "p": "Part-of", "o": "node", "id": 0, "concept": "heap value"}
{"s": "value", "p": "Is-a-Prerequisite-of", "o": "InsertNode", "id": 0, "concept": "heap value"}
{"s": "value", "p": "Is-a-Prerequisite-of", "o": "Remove", "id": 0, "concept": "heap value"}
{"s": "value", "p": "Is-a-Prerequisite-of", "o": "Contains", "id": 0, "concept": "heap value"}
{"s": "value", "p": "Is-a-Prerequisite-of", "o": "FindNode", "id": 0, "concept": "heap value"}
{"s": "value", "p": "Is-a-Prerequisite-of", "o": "FindParent", "id": 0, "concept": "heap value"}
{"s": "value", "p": "Evaluate-for", "o": "heap", "id": 0, "concept": "heap value"}
{"s": "value", "p": "Used-for", "o": "BST", "id": 0, "concept": "heap value"}
{"s": "value", "p": "Used-for", "o": "AVL tree", "id": 0, "concept": "heap value"}
{"s": "value", "p": "Used-for", "o": "search tree", "id": 0, "concept": "heap value"}
{"s": "algorithm", "p": "Is-a-Prerequisite-of", "o": "data structures", "id": 0, "concept": "algorithm remove"}
{"s": "algorithm", "p": "Used-for", "o": "problem solving", "id": 0, "concept": "algorithm remove"}
{"s": "algorithm", "p": "Part-of", "o": "computer science", "id": 0, "concept": "algorithm remove"}
{"s": "Remove algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 0, "concept": "algorithm remove"}
{"s": "Traverse algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 0, "concept": "algorithm remove"}
{"s": "ReverseTraversal algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 0, "concept": "algorithm remove"}
{"s": "Doubly linked lists", "p": "Used-for", "o": "Remove algorithm", "id": 0, "concept": "algorithm remove"}
{"s": "helper algorithms", "p": "Part-of", "o": "Remove algorithm", "id": 0, "concept": "algorithm remove"}
{"s": "Contains algorithm", "p": "Compare", "o": "Remove algorithm", "id": 0, "concept": "algorithm remove"}
{"s": "MaxHeapify algorithm", "p": "Compare", "o": "Min-Heapify algorithm", "id": 0, "concept": "algorithm remove"}
{"s": "LeftRotation algorithm", "p": "Conjunction", "o": "RightRotation algorithm", "id": 0, "concept": "algorithm remove"}
{"s": "LeftAndRightRotation", "p": "Hyponym-Of", "o": "algorithm", "id": 0, "concept": "algorithm remove"}
{"s": "RightAndLeftRotation", "p": "Hyponym-Of", "o": "algorithm", "id": 0, "concept": "algorithm remove"}
{"s": "Mergesort algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 0, "concept": "algorithm remove"}
{"s": "recursive algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 0, "concept": "algorithm remove"}
{"s": "isPrime algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 0, "concept": "algorithm remove"}
{"s": "GreatestCommonDenominator algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 0, "concept": "algorithm remove"}
{"s": "MaxValue algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 0, "concept": "algorithm remove"}
{"s": "SequentialSearch algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 0, "concept": "algorithm remove"}
{"s": "ProbabilitySearch algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 0, "concept": "algorithm remove"}
{"s": "ReverseWords algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 0, "concept": "algorithm remove"}
{"s": "WordCount algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 0, "concept": "algorithm remove"}
{"s": "RepeatedWordCount algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 0, "concept": "algorithm remove"}
{"s": "IsPalindrome algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 0, "concept": "algorithm remove"}
{"s": "Fibonacci algorithm", "p": "Hyponym-Of", "o": "algorithm", "id": 0, "concept": "algorithm remove"}
{"s": "Figure 11.4", "p": "Part-of", "o": "Undesired uniques set", "id": 0, "concept": "101 figure 11 undesired"}
{"s": "Undesired uniques set", "p": "Compare", "o": "Desired uniques set", "id": 0, "concept": "101 figure 11 undesired"}
{"s": "AVL tree", "p": "Is-a-Prerequisite-of", "o": "logarithmic time complexity", "id": 0, "concept": "avl tree avl"}
{"s": "AVL tree", "p": "Hyponym-Of", "o": "binary search tree", "id": 0, "concept": "avl tree avl"}
{"s": "AVL tree", "p": "Part-of", "o": "ordered set", "id": 0, "concept": "avl tree avl"}
{"s": "binary search tree", "p": "Compare", "o": "AVL tree", "id": 0, "concept": "avl tree avl"}
{"s": "AVL tree", "p": "Evaluate-for", "o": "efficiency", "id": 0, "concept": "avl tree avl"}
{"s": "AVL tree", "p": "Compare", "o": "linear complexity", "id": 0, "concept": "avl tree avl"}
{"s": "AVL tree", "p": "Is-a-Prerequisite-of", "o": "logarithmic time complexity", "id": 1, "concept": "pre number compute factorial"}
{"s": "AVL tree", "p": "Hyponym-Of", "o": "binary search tree", "id": 1, "concept": "pre number compute factorial"}
{"s": "AVL tree", "p": "Part-of", "o": "ordered set", "id": 1, "concept": "pre number compute factorial"}
{"s": "AVL tree", "p": "Used-for", "o": "avoiding worst case linear complexity runtimes", "id": 1, "concept": "pre number compute factorial"}
{"s": "binary search tree", "p": "Compare", "o": "AVL tree", "id": 1, "concept": "pre number compute factorial"}
{"s": "AVL tree", "p": "Compare", "o": "binary search tree", "id": 1, "concept": "pre number compute factorial"}
{"s": "AVL tree", "p": "Is-a-Prerequisite-of", "o": "logarithmic time complexity", "id": 2, "concept": "left height current right"}
{"s": "AVL tree", "p": "Hyponym-Of", "o": "binary search tree", "id": 2, "concept": "left height current right"}
{"s": "AVL tree", "p": "Part-of", "o": "ordered set", "id": 2, "concept": "left height current right"}
{"s": "AVL tree", "p": "Used-for", "o": "avoiding worst-case linear complexity", "id": 2, "concept": "left height current right"}
{"s": "binary search tree", "p": "Compare", "o": "AVL tree", "id": 2, "concept": "left height current right"}
{"s": "AVL tree", "p": "Evaluate-for", "o": "effectiveness", "id": 2, "concept": "left height current right"}
{"s": "AVL tree", "p": "Is-a-Prerequisite-of", "o": "logarithmic time", "id": 3, "concept": "unordered set"}
{"s": "AVL tree", "p": "Hyponym-Of", "o": "binary search tree", "id": 3, "concept": "unordered set"}
{"s": "AVL tree", "p": "Part-of", "o": "ordered set", "id": 3, "concept": "unordered set"}
{"s": "AVL tree", "p": "Used-for", "o": "avoiding worst case linear complexity runtimes", "id": 3, "concept": "unordered set"}
{"s": "binary search tree", "p": "Compare", "o": "AVL tree", "id": 3, "concept": "unordered set"}
{"s": "AVL tree", "p": "Evaluate-for", "o": "efficiency", "id": 3, "concept": "unordered set"}
{"s": "AVL tree", "p": "Is-a-Prerequisite-of", "o": "logarithmic time complexity", "id": 4, "concept": "root value yield root"}
{"s": "AVL tree", "p": "Hyponym-Of", "o": "binary search tree", "id": 4, "concept": "root value yield root"}
{"s": "AVL tree", "p": "Part-of", "o": "ordered set", "id": 4, "concept": "root value yield root"}
{"s": "binary search tree", "p": "Compare", "o": "AVL tree", "id": 4, "concept": "root value yield root"}
{"s": "AVL tree", "p": "Evaluate-for", "o": "effectiveness", "id": 4, "concept": "root value yield root"}
{"s": "AVL tree", "p": "Compare", "o": "linear complexity", "id": 4, "concept": "root value yield root"}
{"s": "type check", "p": "Is-a-Prerequisite-of", "o": "custom type checks", "id": 0, "concept": "type check type"}
{"s": "type check", "p": "Is-a-Prerequisite-of", "o": "custom type checks", "id": 1, "concept": "search tree binary"}
{"s": "type check", "p": "Is-a-Prerequisite-of", "o": "custom type checks", "id": 2, "concept": "root left postorder"}
{"s": "type check", "p": "Is-a-Prerequisite-of", "o": "custom type checks", "id": 4, "concept": "left enqueue root right"}
{"s": "algorithm implementation", "p": "Is-a-Prerequisite-of", "o": "vast majority case satisfied", "id": 0, "concept": "vast majority case satis\ufb01ed"}
{"s": "imperative programming", "p": "Conjunction", "o": "algorithm implementation", "id": 0, "concept": "vast majority case satis\ufb01ed"}
{"s": "algorithm", "p": "Is-a-Prerequisite-of", "o": "implementing", "id": 1, "concept": "sure unit test"}
{"s": "algorithm implementation", "p": "Is-a-Prerequisite-of", "o": "vast majority case satisfied", "id": 3, "concept": "item deque"}
{"s": "imperative programming", "p": "Conjunction", "o": "algorithm implementation", "id": 3, "concept": "item deque"}
{"s": "algorithm implementation", "p": "Is-a-Prerequisite-of", "o": "vast majority case satisfied", "id": 4, "concept": "tree chapter binary search"}
{"s": "imperative programming", "p": "Conjunction", "o": "algorithm implementation", "id": 4, "concept": "tree chapter binary search"}
{"s": "Postorder", "p": "Part-of", "o": "Tree Traversal", "id": 0, "concept": "postorder root left postorder"}
{"s": "Preorder", "p": "Part-of", "o": "Tree Traversal", "id": 0, "concept": "postorder root left postorder"}
{"s": "Postorder", "p": "Compare", "o": "Preorder", "id": 0, "concept": "postorder root left postorder"}
{"s": "Left", "p": "Part-of", "o": "Binary Tree", "id": 0, "concept": "postorder root left postorder"}
{"s": "Root", "p": "Part-of", "o": "Binary Tree", "id": 0, "concept": "postorder root left postorder"}
{"s": "Postorder", "p": "Part-of", "o": "Tree Traversal", "id": 1, "concept": "node linked list"}
{"s": "Preorder", "p": "Part-of", "o": "Tree Traversal", "id": 1, "concept": "node linked list"}
{"s": "Postorder", "p": "Conjunction", "o": "Preorder", "id": 1, "concept": "node linked list"}
{"s": "Left", "p": "Part-of", "o": "Binary Tree", "id": 1, "concept": "node linked list"}
{"s": "Root", "p": "Part-of", "o": "Binary Tree", "id": 1, "concept": "node linked list"}
{"s": "Postorder", "p": "Part-of", "o": "Tree Traversal Algorithm", "id": 2, "concept": "data structure operating"}
{"s": "Preorder", "p": "Part-of", "o": "Tree Traversal Algorithm", "id": 2, "concept": "data structure operating"}
{"s": "Postorder", "p": "Compare", "o": "Preorder", "id": 2, "concept": "data structure operating"}
{"s": "Left", "p": "Part-of", "o": "Tree", "id": 2, "concept": "data structure operating"}
{"s": "Root", "p": "Part-of", "o": "Tree", "id": 2, "concept": "data structure operating"}
{"s": "Postorder", "p": "Part-of", "o": "Tree Traversal Algorithm", "id": 3, "concept": "algorithm remove head"}
{"s": "Preorder", "p": "Part-of", "o": "Tree Traversal Algorithm", "id": 3, "concept": "algorithm remove head"}
{"s": "Postorder", "p": "Compare", "o": "Preorder", "id": 3, "concept": "algorithm remove head"}
{"s": "Left", "p": "Part-of", "o": "Binary Tree", "id": 3, "concept": "algorithm remove head"}
{"s": "Root", "p": "Part-of", "o": "Binary Tree", "id": 3, "concept": "algorithm remove head"}
{"s": "bst", "p": "Part-of", "o": "root", "id": 0, "concept": "bst located pre root"}
{"s": "bst", "p": "Part-of", "o": "value", "id": 0, "concept": "bst located pre root"}
{"s": "value", "p": "Compare", "o": "located", "id": 0, "concept": "bst located pre root"}
{"s": "value", "p": "Compare", "o": "not located", "id": 0, "concept": "bst located pre root"}
{"s": "bst", "p": "Part-of", "o": "root", "id": 1, "concept": "list count list index"}
{"s": "bst", "p": "Part-of", "o": "value", "id": 1, "concept": "list count list index"}
{"s": "value", "p": "Compare", "o": "located", "id": 1, "concept": "list count list index"}
{"s": "located", "p": "Conjunction", "o": "not located", "id": 1, "concept": "list count list index"}
{"s": "bst", "p": "Part-of", "o": "root", "id": 2, "concept": "algorithm insert"}
{"s": "bst", "p": "Part-of", "o": "value", "id": 2, "concept": "algorithm insert"}
{"s": "located", "p": "Conjunction", "o": "not located", "id": 2, "concept": "algorithm insert"}
{"s": "bst", "p": "Part-of", "o": "root", "id": 3, "concept": "number compute factorial"}
{"s": "bst", "p": "Part-of", "o": "value", "id": 3, "concept": "number compute factorial"}
{"s": "value", "p": "Compare", "o": "located", "id": 3, "concept": "number compute factorial"}
{"s": "value", "p": "Compare", "o": "not located", "id": 3, "concept": "number compute factorial"}
{"s": "bst", "p": "Part-of", "o": "root", "id": 4, "concept": "problem lot simpler"}
{"s": "bst", "p": "Part-of", "o": "value", "id": 4, "concept": "problem lot simpler"}
{"s": "value", "p": "Compare", "o": "located", "id": 4, "concept": "problem lot simpler"}
{"s": "value", "p": "Compare", "o": "not located", "id": 4, "concept": "problem lot simpler"}
{"s": "factorial algorithm", "p": "Is-a-Prerequisite-of", "o": "recursive implementations", "id": 0, "concept": "problem spurred"}
{"s": "factorial algorithm", "p": "Is-a-Prerequisite-of", "o": "recursive implementations", "id": 1, "concept": "algorithm insert value"}
{"s": "factorial algorithm", "p": "Is-a-Prerequisite-of", "o": "recursive implementations", "id": 2, "concept": "order deque property"}
{"s": "factorial algorithm", "p": "Is-a-Prerequisite-of", "o": "recursive implementations", "id": 3, "concept": "line 25 false case"}
{"s": "factorial algorithm", "p": "Is-a-Prerequisite-of", "o": "recursive implementations", "id": 4, "concept": "return caller exhausted"}
{"s": "parent index", "p": "Part-of", "o": "Binary Heap", "id": 0, "concept": "parent index"}
{"s": "parent index", "p": "Used-for", "o": "FindParent", "id": 0, "concept": "parent index"}
{"s": "index", "p": "Compare", "o": "parent index", "id": 0, "concept": "parent index"}
{"s": "parent node", "p": "Part-of", "o": "Binary Heap", "id": 0, "concept": "parent index"}
{"s": "child node", "p": "Part-of", "o": "Binary Heap", "id": 0, "concept": "parent index"}
{"s": "parent node", "p": "Is-a-Prerequisite-of", "o": "min heap", "id": 0, "concept": "parent index"}
{"s": "parent node", "p": "Is-a-Prerequisite-of", "o": "max heap", "id": 0, "concept": "parent index"}
{"s": "value", "p": "Used-for", "o": "FindParent", "id": 0, "concept": "parent index"}
{"s": "value", "p": "Used-for", "o": "FindNode", "id": 0, "concept": "parent index"}
{"s": "parent index", "p": "Part-of", "o": "Binary Heap", "id": 1, "concept": "root right postorder"}
{"s": "parent index", "p": "Used-for", "o": "FindParent", "id": 1, "concept": "root right postorder"}
{"s": "parent index", "p": "Compare", "o": "child index", "id": 1, "concept": "root right postorder"}
{"s": "index", "p": "Is-a-Prerequisite-of", "o": "FindParent", "id": 1, "concept": "root right postorder"}
{"s": "index", "p": "Part-of", "o": "algorithm", "id": 1, "concept": "root right postorder"}
{"s": "Binary Heap", "p": "Conjunction", "o": "min heap", "id": 1, "concept": "root right postorder"}
{"s": "Binary Heap", "p": "Conjunction", "o": "max heap", "id": 1, "concept": "root right postorder"}
{"s": "parent index", "p": "Part-of", "o": "Binary Heap", "id": 2, "concept": "root left enqueue"}
{"s": "parent index", "p": "Used-for", "o": "FindParent", "id": 2, "concept": "root left enqueue"}
{"s": "parent index", "p": "Compare", "o": "child index", "id": 2, "concept": "root left enqueue"}
{"s": "index", "p": "Is-a-Prerequisite-of", "o": "FindParent", "id": 2, "concept": "root left enqueue"}
{"s": "index", "p": "Used-for", "o": "FindNode", "id": 2, "concept": "root left enqueue"}
{"s": "Binary Heap", "p": "Conjunction", "o": "Min Heap", "id": 2, "concept": "root left enqueue"}
{"s": "Binary Heap", "p": "Conjunction", "o": "Max Heap", "id": 2, "concept": "root left enqueue"}
{"s": "Min Heap", "p": "Compare", "o": "Max Heap", "id": 2, "concept": "root left enqueue"}
{"s": "FindParent", "p": "Used-for", "o": "FindNode", "id": 2, "concept": "root left enqueue"}
{"s": "FindParent", "p": "Part-of", "o": "Algorithm", "id": 2, "concept": "root left enqueue"}
{"s": "parent index", "p": "Part-of", "o": "heap", "id": 3, "concept": "platform modern language like"}
{"s": "parent index", "p": "Used-for", "o": "FindParent", "id": 3, "concept": "platform modern language like"}
{"s": "parent index", "p": "Compare", "o": "child index", "id": 3, "concept": "platform modern language like"}
{"s": "min heap", "p": "Is-a-Prerequisite-of", "o": "parent index", "id": 3, "concept": "platform modern language like"}
{"s": "max heap", "p": "Is-a-Prerequisite-of", "o": "parent index", "id": 3, "concept": "platform modern language like"}
{"s": "FindParent", "p": "Used-for", "o": "parent index", "id": 3, "concept": "platform modern language like"}
{"s": "FindNode", "p": "Conjunction", "o": "FindParent", "id": 3, "concept": "platform modern language like"}
{"s": "parent index", "p": "Part-of", "o": "Heap data structure", "id": 4, "concept": "return false return false"}
{"s": "parent index", "p": "Used-for", "o": "FindParent algorithm", "id": 4, "concept": "return false return false"}
{"s": "parent index", "p": "Compare", "o": "child index", "id": 4, "concept": "return false return false"}
{"s": "index", "p": "Part-of", "o": "Array", "id": 4, "concept": "return false return false"}
{"s": "FindParent algorithm", "p": "Used-for", "o": "finding parent node", "id": 4, "concept": "return false return false"}
{"s": "FindNode algorithm", "p": "Conjunction", "o": "FindParent algorithm", "id": 4, "concept": "return false return false"}
{"s": "min heap", "p": "Is-a-Prerequisite-of", "o": "parent node value comparison", "id": 4, "concept": "return false return false"}
{"s": "max heap", "p": "Compare", "o": "min heap", "id": 4, "concept": "return false return false"}
{"s": "node", "p": "Part-of", "o": "tree", "id": 4, "concept": "return false return false"}
{"s": "child", "p": "Part-of", "o": "node", "id": 4, "concept": "return false return false"}
{"s": "value", "p": "Part-of", "o": "node", "id": 4, "concept": "return false return false"}
{"s": "AVL tree", "p": "Is-a-Prerequisite-of", "o": "Ordered set", "id": 0, "concept": "avl tree"}
{"s": "AVL tree", "p": "Hyponym-Of", "o": "Binary Search Tree", "id": 0, "concept": "avl tree"}
{"s": "AVL tree", "p": "Part-of", "o": "Binary Search Tree", "id": 0, "concept": "avl tree"}
{"s": "AVL tree", "p": "Compare", "o": "Binary Search Tree", "id": 0, "concept": "avl tree"}
{"s": "Tree rotation", "p": "Used-for", "o": "AVL tree", "id": 0, "concept": "avl tree"}
{"s": "Tree", "p": "Part-of", "o": "AVL tree", "id": 0, "concept": "avl tree"}
{"s": "Tree", "p": "Part-of", "o": "Heap", "id": 0, "concept": "avl tree"}
{"s": "Heap", "p": "Compare", "o": "Tree", "id": 0, "concept": "avl tree"}
{"s": "Linked list", "p": "Compare", "o": "Tree", "id": 0, "concept": "avl tree"}
{"s": "Algorithm", "p": "Used-for", "o": "AVL tree", "id": 0, "concept": "avl tree"}
{"s": "AVL tree", "p": "Is-a-Prerequisite-of", "o": "Ordered set", "id": 1, "concept": "array used store heap"}
{"s": "AVL tree", "p": "Hyponym-Of", "o": "Binary Search Tree", "id": 1, "concept": "array used store heap"}
{"s": "Binary Search Tree", "p": "Part-of", "o": "AVL tree", "id": 1, "concept": "array used store heap"}
{"s": "Tree rotation", "p": "Used-for", "o": "AVL tree", "id": 1, "concept": "array used store heap"}
{"s": "Tree", "p": "Part-of", "o": "AVL tree", "id": 1, "concept": "array used store heap"}
{"s": "Tree traversal", "p": "Used-for", "o": "AVL tree", "id": 1, "concept": "array used store heap"}
{"s": "Algorithm", "p": "Used-for", "o": "AVL tree", "id": 1, "concept": "array used store heap"}
{"s": "AVL tree", "p": "Compare", "o": "Binary Search Tree", "id": 1, "concept": "array used store heap"}
{"s": "AVL tree", "p": "Evaluate-for", "o": "Efficiency", "id": 1, "concept": "array used store heap"}
{"s": "Linked list", "p": "Compare", "o": "AVL tree", "id": 1, "concept": "array used store heap"}
{"s": "AVL tree", "p": "Is-a-Prerequisite-of", "o": "ordered set", "id": 2, "concept": "node tree"}
{"s": "AVL tree", "p": "Hyponym-Of", "o": "binary search tree", "id": 2, "concept": "node tree"}
{"s": "binary search tree", "p": "Part-of", "o": "AVL tree", "id": 2, "concept": "node tree"}
{"s": "tree rotation", "p": "Used-for", "o": "AVL tree", "id": 2, "concept": "node tree"}
{"s": "tree", "p": "Part-of", "o": "AVL tree", "id": 2, "concept": "node tree"}
{"s": "algorithm", "p": "Used-for", "o": "AVL tree", "id": 2, "concept": "node tree"}
{"s": "AVL tree", "p": "Compare", "o": "binary search tree", "id": 2, "concept": "node tree"}
{"s": "AVL tree", "p": "Evaluate-for", "o": "efficiency", "id": 2, "concept": "node tree"}
{"s": "tree", "p": "Compare", "o": "linked list", "id": 2, "concept": "node tree"}
{"s": "heap", "p": "Compare", "o": "tree", "id": 2, "concept": "node tree"}
{"s": "array", "p": "Used-for", "o": "heap", "id": 2, "concept": "node tree"}
{"s": "array", "p": "Used-for", "o": "tree", "id": 2, "concept": "node tree"}
{"s": "AVL tree", "p": "Hyponym-Of", "o": "Binary Search Tree", "id": 3, "concept": "avl balance"}
{"s": "AVL tree", "p": "Is-a-Prerequisite-of", "o": "Tree Rotation", "id": 3, "concept": "avl balance"}
{"s": "AVL tree", "p": "Compare", "o": "Binary Search Tree", "id": 3, "concept": "avl balance"}
{"s": "Binary Search Tree", "p": "Part-of", "o": "AVL tree", "id": 3, "concept": "avl balance"}
{"s": "Tree", "p": "Part-of", "o": "AVL tree", "id": 3, "concept": "avl balance"}
{"s": "Tree", "p": "Used-for", "o": "Tree Traversal", "id": 3, "concept": "avl balance"}
{"s": "AVL tree", "p": "Evaluate-for", "o": "Time Complexity", "id": 3, "concept": "avl balance"}
{"s": "AVL tree", "p": "Evaluate-for", "o": "Height", "id": 3, "concept": "avl balance"}
{"s": "AVL tree", "p": "Used-for", "o": "Ordered Set", "id": 3, "concept": "avl balance"}
{"s": "Linked List", "p": "Compare", "o": "Tree", "id": 3, "concept": "avl balance"}
{"s": "Heap", "p": "Compare", "o": "Tree", "id": 3, "concept": "avl balance"}
{"s": "Array", "p": "Used-for", "o": "Heap Implementation", "id": 3, "concept": "avl balance"}
{"s": "AVL tree", "p": "Hyponym-Of", "o": "Binary Search Tree", "id": 4, "concept": "pivot moving smaller item"}
{"s": "AVL tree", "p": "Used-for", "o": "Ordered set", "id": 4, "concept": "pivot moving smaller item"}
{"s": "Binary Search Tree", "p": "Part-of", "o": "AVL tree", "id": 4, "concept": "pivot moving smaller item"}
{"s": "Tree rotation", "p": "Used-for", "o": "AVL tree", "id": 4, "concept": "pivot moving smaller item"}
{"s": "Tree", "p": "Part-of", "o": "AVL tree", "id": 4, "concept": "pivot moving smaller item"}
{"s": "Tree", "p": "Part-of", "o": "Heap", "id": 4, "concept": "pivot moving smaller item"}
{"s": "AVL tree", "p": "Compare", "o": "Binary Search Tree", "id": 4, "concept": "pivot moving smaller item"}
{"s": "AVL tree", "p": "Evaluate-for", "o": "efficiency", "id": 4, "concept": "pivot moving smaller item"}
{"s": "Linked list", "p": "Compare", "o": "Tree", "id": 4, "concept": "pivot moving smaller item"}
{"s": "queue", "p": "Part-of", "o": "EnqueueFront", "id": 0, "concept": "queue enqueue root"}
{"s": "queue", "p": "Used-for", "o": "algorithm", "id": 0, "concept": "queue enqueue root"}
{"s": "queue", "p": "Part-of", "o": "EnqueueFront", "id": 1, "concept": "yield root value"}
{"s": "queue", "p": "Used-for", "o": "algorithm", "id": 1, "concept": "yield root value"}
{"s": "queue", "p": "Part-of", "o": "EnqueueFront", "id": 2, "concept": "post list sorted value"}
{"s": "queue", "p": "Used-for", "o": "algorithm", "id": 2, "concept": "post list sorted value"}
{"s": "queue", "p": "Part-of", "o": "EnqueueFront", "id": 3, "concept": "return keyword cause method"}
{"s": "queue", "p": "Used-for", "o": "algorithm", "id": 3, "concept": "return keyword cause method"}
{"s": "queue", "p": "Part-of", "o": "EnqueueFront", "id": 4, "concept": "populated bst pre root"}
{"s": "queue", "p": "Used-for", "o": "algorithm", "id": 4, "concept": "populated bst pre root"}
{"s": "Priority Queue", "p": "Part-of", "o": "Queue", "id": 1, "concept": "queue highest priority"}
{"s": "Priority Queue", "p": "Used-for", "o": "Comparer", "id": 1, "concept": "queue highest priority"}
{"s": "Highest Priority", "p": "Compare", "o": "Lowest Priority", "id": 1, "concept": "queue highest priority"}
{"s": "Priority Queue", "p": "Part-of", "o": "queue", "id": 3, "concept": "method call"}
{"s": "Priority Queue", "p": "Used-for", "o": "comparer", "id": 3, "concept": "method call"}
{"s": "Priority Queue", "p": "Part-of", "o": "queue", "id": 4, "concept": "postorder postorder root left"}
{"s": "Priority Queue", "p": "Used-for", "o": "comparer", "id": 4, "concept": "postorder postorder root left"}
{"s": "list", "p": "Part-of", "o": "data structure", "id": 0, "concept": "list increment list"}
{"s": "list", "p": "Used-for", "o": "algorithm", "id": 0, "concept": "list increment list"}
{"s": "increment", "p": "Part-of", "o": "algorithm", "id": 0, "concept": "list increment list"}
{"s": "increment", "p": "Used-for", "o": "list", "id": 0, "concept": "list increment list"}
{"s": "list", "p": "Part-of", "o": "data structure", "id": 1, "concept": "queue priority"}
{"s": "list", "p": "Used-for", "o": "algorithm", "id": 1, "concept": "queue priority"}
{"s": "increment", "p": "Part-of", "o": "algorithm", "id": 1, "concept": "queue priority"}
{"s": "increment", "p": "Used-for", "o": "list manipulation", "id": 1, "concept": "queue priority"}
{"s": "list", "p": "Compare", "o": "stack", "id": 1, "concept": "queue priority"}
{"s": "index", "p": "Part-of", "o": "list", "id": 1, "concept": "queue priority"}
{"s": "memory", "p": "Part-of", "o": "computer", "id": 1, "concept": "queue priority"}
{"s": "memory", "p": "Used-for", "o": "list", "id": 1, "concept": "queue priority"}
{"s": "increment", "p": "Used-for", "o": "memory management", "id": 1, "concept": "queue priority"}
{"s": "list", "p": "Part-of", "o": "data structure", "id": 2, "concept": "algorithm sorting"}
{"s": "list", "p": "Used-for", "o": "algorithm", "id": 2, "concept": "algorithm sorting"}
{"s": "increment", "p": "Part-of", "o": "algorithm", "id": 2, "concept": "algorithm sorting"}
{"s": "list", "p": "Compare", "o": "stack", "id": 2, "concept": "algorithm sorting"}
{"s": "increment", "p": "Used-for", "o": "list manipulation", "id": 2, "concept": "algorithm sorting"}
{"s": "list", "p": "Conjunction", "o": "increment", "id": 2, "concept": "algorithm sorting"}
{"s": "list", "p": "Part-of", "o": "list increment list", "id": 3, "concept": "factorial pre number"}
{"s": "list increment", "p": "Used-for", "o": "list", "id": 3, "concept": "factorial pre number"}
{"s": "list", "p": "Compare", "o": "list", "id": 3, "concept": "factorial pre number"}
{"s": "increment", "p": "Part-of", "o": "list increment list", "id": 3, "concept": "factorial pre number"}
{"s": "list", "p": "Part-of", "o": "data structure", "id": 4, "concept": "type parameter"}
{"s": "list", "p": "Used-for", "o": "algorithm", "id": 4, "concept": "type parameter"}
{"s": "increment", "p": "Part-of", "o": "algorithm", "id": 4, "concept": "type parameter"}
{"s": "list", "p": "Compare", "o": "stack", "id": 4, "concept": "type parameter"}
{"s": "increment", "p": "Used-for", "o": "list", "id": 4, "concept": "type parameter"}
{"s": "Big Oh notation", "p": "Is-a-Prerequisite-of", "o": "Algorithm runtime complexity analysis", "id": 0, "concept": "oh notation"}
{"s": "Big Oh notation", "p": "Used-for", "o": "Communication between developers", "id": 0, "concept": "oh notation"}
{"s": "Big Oh notation", "p": "Compare", "o": "Binary Search", "id": 0, "concept": "oh notation"}
{"s": "Big Oh notation", "p": "Compare", "o": "Other search algorithms", "id": 0, "concept": "oh notation"}
{"s": "Algorithm runtime complexity analysis", "p": "Part-of", "o": "Computer Science", "id": 0, "concept": "oh notation"}
{"s": "Binary Search", "p": "Hyponym-Of", "o": "Search Algorithm", "id": 0, "concept": "oh notation"}
{"s": "Left Rotation", "p": "Conjunction", "o": "Right Rotation", "id": 0, "concept": "oh notation"}
{"s": "Left Rotation", "p": "Part-of", "o": "Tree Rotation", "id": 0, "concept": "oh notation"}
{"s": "Right Rotation", "p": "Part-of", "o": "Tree Rotation", "id": 0, "concept": "oh notation"}
{"s": "LeftAndRightRotation", "p": "Part-of", "o": "Tree Rotation", "id": 0, "concept": "oh notation"}
{"s": "RightAndLeftRotation", "p": "Part-of", "o": "Tree Rotation", "id": 0, "concept": "oh notation"}
{"s": "LeftAndRightRotation", "p": "Conjunction", "o": "RightAndLeftRotation", "id": 0, "concept": "oh notation"}
{"s": "Tree Rotation", "p": "Evaluate-for", "o": "Runtime Complexity", "id": 0, "concept": "oh notation"}
{"s": "Algorithm", "p": "Is-a-Prerequisite-of", "o": "Software Development", "id": 0, "concept": "oh notation"}
{"s": "root", "p": "Part-of", "o": "value", "id": 1, "concept": "end end inword end"}
{"s": "value", "p": "Conjunction", "o": "yield", "id": 1, "concept": "end end inword end"}
{"s": "root", "p": "Part-of", "o": "value", "id": 2, "concept": "item choosing appropriate pivot"}
{"s": "value", "p": "Conjunction", "o": "yield", "id": 2, "concept": "item choosing appropriate pivot"}
{"s": "Binary Search Tree", "p": "Is-a-Prerequisite-of", "o": "Data Structure", "id": 0, "concept": "binary search tree binary"}
{"s": "Binary Search Tree", "p": "Compare", "o": "AVL Tree", "id": 0, "concept": "binary search tree binary"}
{"s": "Binary Search Tree", "p": "Part-of", "o": "Root", "id": 0, "concept": "binary search tree binary"}
{"s": "Binary Search Tree", "p": "Used-for", "o": "Representing Ordered Data", "id": 0, "concept": "binary search tree binary"}
{"s": "Inorder Traversal", "p": "Part-of", "o": "Tree Traversal", "id": 0, "concept": "binary search tree binary"}
{"s": "Preorder Traversal", "p": "Part-of", "o": "Tree Traversal", "id": 0, "concept": "binary search tree binary"}
{"s": "Postorder Traversal", "p": "Part-of", "o": "Tree Traversal", "id": 0, "concept": "binary search tree binary"}
{"s": "Breadth-First Traversal", "p": "Part-of", "o": "Tree Traversal", "id": 0, "concept": "binary search tree binary"}
{"s": "AVL Tree", "p": "Hyponym-Of", "o": "Binary Search Tree", "id": 0, "concept": "binary search tree binary"}
{"s": "Binary Search", "p": "Compare", "o": "Binary Search Tree", "id": 0, "concept": "binary search tree binary"}
{"s": "Binary Search", "p": "Conjunction", "o": "Binary Chop", "id": 0, "concept": "binary search tree binary"}
{"s": "Binary Search Tree", "p": "Is-a-Prerequisite-of", "o": "AVL Tree", "id": 1, "concept": "list return list"}
{"s": "Binary Search Tree", "p": "Compare", "o": "AVL Tree", "id": 1, "concept": "list return list"}
{"s": "Binary Search Tree", "p": "Part-of", "o": "Root", "id": 1, "concept": "list return list"}
{"s": "Preorder traversal", "p": "Part-of", "o": "Binary Search Tree", "id": 1, "concept": "list return list"}
{"s": "Postorder traversal", "p": "Part-of", "o": "Binary Search Tree", "id": 1, "concept": "list return list"}
{"s": "Inorder traversal", "p": "Part-of", "o": "Binary Search Tree", "id": 1, "concept": "list return list"}
{"s": "Breadth-First traversal", "p": "Part-of", "o": "Binary Search Tree", "id": 1, "concept": "list return list"}
{"s": "Tree Rotation", "p": "Used-for", "o": "Binary Search Tree", "id": 1, "concept": "list return list"}
{"s": "Binary Search", "p": "Compare", "o": "Binary Search Tree", "id": 1, "concept": "list return list"}
{"s": "Binary Search Tree", "p": "Is-a-Prerequisite-of", "o": "AVL Tree", "id": 2, "concept": "string figure"}
{"s": "Binary Search Tree", "p": "Compare", "o": "AVL Tree", "id": 2, "concept": "string figure"}
{"s": "Binary Search Tree", "p": "Part-of", "o": "Root", "id": 2, "concept": "string figure"}
{"s": "Binary Search Tree", "p": "Used-for", "o": "Data Representation", "id": 2, "concept": "string figure"}
{"s": "Inorder visit", "p": "Part-of", "o": "Binary Search Tree", "id": 2, "concept": "string figure"}
{"s": "Preorder visit", "p": "Part-of", "o": "Binary Search Tree", "id": 2, "concept": "string figure"}
{"s": "Postorder visit", "p": "Part-of", "o": "Binary Search Tree", "id": 2, "concept": "string figure"}
{"s": "Breadth First visit", "p": "Part-of", "o": "Binary Search Tree", "id": 2, "concept": "string figure"}
{"s": "Tree Rotation", "p": "Used-for", "o": "Binary Search Tree", "id": 2, "concept": "string figure"}
{"s": "Binary Search", "p": "Compare", "o": "Binary Search Tree", "id": 2, "concept": "string figure"}
{"s": "Binary Search Tree", "p": "Is-a-Prerequisite-of", "o": "AVL Tree", "id": 3, "concept": "explicitly state end"}
{"s": "Binary Search Tree", "p": "Compare", "o": "AVL Tree", "id": 3, "concept": "explicitly state end"}
{"s": "Binary Search Tree", "p": "Part-of", "o": "Root", "id": 3, "concept": "explicitly state end"}
{"s": "Preorder Traversal", "p": "Part-of", "o": "Binary Search Tree", "id": 3, "concept": "explicitly state end"}
{"s": "Postorder Traversal", "p": "Part-of", "o": "Binary Search Tree", "id": 3, "concept": "explicitly state end"}
{"s": "Inorder Traversal", "p": "Part-of", "o": "Binary Search Tree", "id": 3, "concept": "explicitly state end"}
{"s": "Breadth-First Traversal", "p": "Part-of", "o": "Binary Search Tree", "id": 3, "concept": "explicitly state end"}
{"s": "Tree Rotation", "p": "Used-for", "o": "Binary Search Tree", "id": 3, "concept": "explicitly state end"}
{"s": "Binary Search", "p": "Compare", "o": "Binary Search Tree", "id": 3, "concept": "explicitly state end"}
{"s": "Binary Search Tree", "p": "Is-a-Prerequisite-of", "o": "Data Structure", "id": 4, "concept": "summary description"}
{"s": "Binary Search Tree", "p": "Compare", "o": "AVL Tree", "id": 4, "concept": "summary description"}
{"s": "Binary Search Tree", "p": "Part-of", "o": "Root", "id": 4, "concept": "summary description"}
{"s": "Binary Search Tree", "p": "Used-for", "o": "Representing Ordered Data", "id": 4, "concept": "summary description"}
{"s": "Preorder Traversal", "p": "Part-of", "o": "Binary Search Tree", "id": 4, "concept": "summary description"}
{"s": "Postorder Traversal", "p": "Part-of", "o": "Binary Search Tree", "id": 4, "concept": "summary description"}
{"s": "Inorder Traversal", "p": "Part-of", "o": "Binary Search Tree", "id": 4, "concept": "summary description"}
{"s": "Breadth-First Traversal", "p": "Part-of", "o": "Binary Search Tree", "id": 4, "concept": "summary description"}
{"s": "AVL Tree", "p": "Hyponym-Of", "o": "Binary Search Tree", "id": 4, "concept": "summary description"}
{"s": "yield", "p": "Compare", "o": "returns", "id": 0, "concept": "case yield true"}
{"s": "yield", "p": "Used-for", "o": "Post", "id": 0, "concept": "case yield true"}
{"s": "Post", "p": "Part-of", "o": "node", "id": 0, "concept": "case yield true"}
{"s": "value", "p": "Is-a-Prerequisite-of", "o": "true", "id": 0, "concept": "case yield true"}
{"s": "value", "p": "Is-a-Prerequisite-of", "o": "false", "id": 0, "concept": "case yield true"}
{"s": "yield", "p": "Is-a-Prerequisite-of", "o": "Post", "id": 1, "concept": "number digit"}
{"s": "yield", "p": "Compare", "o": "return", "id": 1, "concept": "number digit"}
{"s": "yield", "p": "Used-for", "o": "Post", "id": 1, "concept": "number digit"}
{"s": "yield", "p": "Is-a-Prerequisite-of", "o": "Post", "id": 2, "concept": "use big oh notation"}
{"s": "yield", "p": "Compare", "o": "returns", "id": 2, "concept": "use big oh notation"}
{"s": "yield", "p": "Compare", "o": "returns", "id": 3, "concept": "end inword"}
{"s": "yield", "p": "Used-for", "o": "Post", "id": 3, "concept": "end inword"}
{"s": "Post", "p": "Part-of", "o": "node", "id": 3, "concept": "end inword"}
{"s": "true", "p": "Conjunction", "o": "false", "id": 3, "concept": "end inword"}
{"s": "yield", "p": "Is-a-Prerequisite-of", "o": "return", "id": 4, "concept": "right nodetoremove left nodetoremove"}
{"s": "yield", "p": "Compare", "o": "return", "id": 4, "concept": "right nodetoremove left nodetoremove"}
{"s": "heap array used", "p": "Part-of", "o": "heap", "id": 0, "concept": "heap array used"}
{"s": "heap array used", "p": "Used-for", "o": "searching", "id": 0, "concept": "heap array used"}
{"s": "heap", "p": "Part-of", "o": "heap array used", "id": 0, "concept": "heap array used"}
{"s": "heap", "p": "Used-for", "o": "storing heap items", "id": 0, "concept": "heap array used"}
{"s": "garbage values", "p": "Part-of", "o": "heap array data", "id": 0, "concept": "heap array used"}
{"s": "dynamic size", "p": "Used-for", "o": "minimising impact", "id": 0, "concept": "heap array used"}
{"s": "index 0", "p": "Part-of", "o": "heap array", "id": 0, "concept": "heap array used"}
{"s": "heap array used", "p": "Part-of", "o": "heap", "id": 1, "concept": "count list index"}
{"s": "heap array used", "p": "Used-for", "o": "searching", "id": 1, "concept": "count list index"}
{"s": "heap", "p": "Part-of", "o": "heap array used", "id": 1, "concept": "count list index"}
{"s": "garbage values", "p": "Part-of", "o": "heap array used", "id": 1, "concept": "count list index"}
{"s": "heap array used", "p": "Part-of", "o": "heap", "id": 2, "concept": "implementation priority queue"}
{"s": "heap array used", "p": "Used-for", "o": "storing heap items", "id": 2, "concept": "implementation priority queue"}
{"s": "heap", "p": "Part-of", "o": "heap array used", "id": 2, "concept": "implementation priority queue"}
{"s": "heap array", "p": "Compare", "o": "backing heap array", "id": 2, "concept": "implementation priority queue"}
{"s": "size for your heap array", "p": "Used-for", "o": "minimising the impact of dynamic", "id": 2, "concept": "implementation priority queue"}
{"s": "item at index 0 within the heap array", "p": "Part-of", "o": "heap array used", "id": 2, "concept": "implementation priority queue"}
{"s": "heap array used", "p": "Part-of", "o": "heap", "id": 3, "concept": "operation implementation factorial"}
{"s": "heap array used", "p": "Used-for", "o": "storing heap items", "id": 3, "concept": "operation implementation factorial"}
{"s": "heap array used", "p": "Used-for", "o": "searching", "id": 3, "concept": "operation implementation factorial"}
{"s": "heap array used", "p": "Used-for", "o": "minimizing the impact of dynamic size", "id": 3, "concept": "operation implementation factorial"}
{"s": "heap array used", "p": "Part-of", "o": "heap", "id": 4, "concept": "heap heap array used"}
{"s": "heap", "p": "Used-for", "o": "storing heap items", "id": 4, "concept": "heap heap array used"}
{"s": "heap array", "p": "Used-for", "o": "searching", "id": 4, "concept": "heap heap array used"}
{"s": "heap array", "p": "Part-of", "o": "backing heap array", "id": 4, "concept": "heap heap array used"}
{"s": "size", "p": "Used-for", "o": "minimising impact of dynamic", "id": 4, "concept": "heap heap array used"}
{"s": "heap array used", "p": "Part-of", "o": "heap", "id": 5, "concept": "searching data structure used"}
{"s": "heap array used", "p": "Used-for", "o": "storing heap items", "id": 5, "concept": "searching data structure used"}
{"s": "heap array used", "p": "Used-for", "o": "searching a heap", "id": 5, "concept": "searching data structure used"}
{"s": "heap array used", "p": "Part-of", "o": "backing heap array", "id": 5, "concept": "searching data structure used"}
{"s": "heap array used", "p": "Evaluate-for", "o": "run time behaviour of a program", "id": 5, "concept": "searching data structure used"}
{"s": "heap array used", "p": "Part-of", "o": "heap", "id": 6, "concept": "introduction chapter introduction book"}
{"s": "heap array used", "p": "Used-for", "o": "searching", "id": 6, "concept": "introduction chapter introduction book"}
{"s": "heap", "p": "Part-of", "o": "heap array used", "id": 6, "concept": "introduction chapter introduction book"}
{"s": "heap array used", "p": "Part-of", "o": "heap", "id": 7, "concept": "introduction chapter introduction"}
{"s": "heap array used", "p": "Used-for", "o": "storing heap items", "id": 7, "concept": "introduction chapter introduction"}
{"s": "heap", "p": "Part-of", "o": "heap array used", "id": 7, "concept": "introduction chapter introduction"}
{"s": "garbage values", "p": "Part-of", "o": "heap array used", "id": 7, "concept": "introduction chapter introduction"}
{"s": "heap array used", "p": "Part-of", "o": "heap", "id": 8, "concept": "method pushed stack return"}
{"s": "heap array used", "p": "Used-for", "o": "storing heap items", "id": 8, "concept": "method pushed stack return"}
{"s": "heap", "p": "Part-of", "o": "heap array used", "id": 8, "concept": "method pushed stack return"}
{"s": "size for your heap array", "p": "Used-for", "o": "minimising the impact of dynamic", "id": 8, "concept": "method pushed stack return"}
{"s": "heap array used", "p": "Part-of", "o": "heap", "id": 9, "concept": "message summary summary"}
{"s": "heap array used", "p": "Used-for", "o": "searching", "id": 9, "concept": "message summary summary"}
{"s": "heap", "p": "Part-of", "o": "heap array used", "id": 9, "concept": "message summary summary"}
{"s": "heap", "p": "Used-for", "o": "storing heap items", "id": 9, "concept": "message summary summary"}
{"s": "garbage values", "p": "Part-of", "o": "heap array used", "id": 9, "concept": "message summary summary"}
{"s": "Recursive algorithm", "p": "Is-a-Prerequisite-of", "o": "Algorithm", "id": 0, "concept": "recursion recursive algorithm"}
{"s": "Recursive algorithm", "p": "Compare", "o": "Iterative algorithm", "id": 0, "concept": "recursion recursive algorithm"}
{"s": "Recursive algorithm", "p": "Part-of", "o": "Algorithm", "id": 0, "concept": "recursion recursive algorithm"}
{"s": "Recursive algorithm", "p": "Used-for", "o": "Tree", "id": 0, "concept": "recursion recursive algorithm"}
{"s": "Recursive algorithm", "p": "Evaluate-for", "o": "Run time efficiency", "id": 0, "concept": "recursion recursive algorithm"}
{"s": "Algorithm", "p": "Conjunction", "o": "Recursive algorithm", "id": 0, "concept": "recursion recursive algorithm"}
{"s": "Algorithm", "p": "Conjunction", "o": "Iterative algorithm", "id": 0, "concept": "recursion recursive algorithm"}
{"s": "Recursive algorithm", "p": "Is-a-Prerequisite-of", "o": "Algorithm", "id": 1, "concept": "root node bst post"}
{"s": "Recursive algorithm", "p": "Compare", "o": "Iterative algorithm", "id": 1, "concept": "root node bst post"}
{"s": "Recursive algorithm", "p": "Part-of", "o": "Algorithm", "id": 1, "concept": "root node bst post"}
{"s": "Recursive algorithm", "p": "Used-for", "o": "Tree", "id": 1, "concept": "root node bst post"}
{"s": "Algorithm", "p": "Conjunction", "o": "Recursive algorithm", "id": 1, "concept": "root node bst post"}
{"s": "Algorithm", "p": "Conjunction", "o": "Iterative algorithm", "id": 1, "concept": "root node bst post"}
{"s": "Recursive algorithm", "p": "Is-a-Prerequisite-of", "o": "Algorithm", "id": 2, "concept": "recursive v"}
{"s": "Recursive algorithm", "p": "Compare", "o": "Iterative algorithm", "id": 2, "concept": "recursive v"}
{"s": "Recursive algorithm", "p": "Part-of", "o": "Algorithm", "id": 2, "concept": "recursive v"}
{"s": "Recursive algorithm", "p": "Used-for", "o": "Tree", "id": 2, "concept": "recursive v"}
{"s": "Recursive algorithm", "p": "Evaluate-for", "o": "Run time efficiency", "id": 2, "concept": "recursive v"}
{"s": "Algorithm", "p": "Conjunction", "o": "Recursive algorithm", "id": 2, "concept": "recursive v"}
{"s": "Algorithm", "p": "Conjunction", "o": "Iterative algorithm", "id": 2, "concept": "recursive v"}
{"s": "Recursive algorithm", "p": "Is-a-Prerequisite-of", "o": "Algorithm", "id": 3, "concept": "implementation priority queue use"}
{"s": "Recursive algorithm", "p": "Compare", "o": "Iterative algorithm", "id": 3, "concept": "implementation priority queue use"}
{"s": "Recursive algorithm", "p": "Part-of", "o": "Algorithm", "id": 3, "concept": "implementation priority queue use"}
{"s": "Recursive algorithm", "p": "Used-for", "o": "Tree", "id": 3, "concept": "implementation priority queue use"}
{"s": "Recursive algorithm", "p": "Evaluate-for", "o": "Run time efficiency", "id": 3, "concept": "implementation priority queue use"}
{"s": "Algorithm", "p": "Conjunction", "o": "Recursive algorithm", "id": 3, "concept": "implementation priority queue use"}
{"s": "Algorithm", "p": "Conjunction", "o": "Iterative algorithm", "id": 3, "concept": "implementation priority queue use"}
{"s": "Recursive algorithm", "p": "Is-a-Prerequisite-of", "o": "Algorithm", "id": 4, "concept": "recursive algorithm appendix"}
{"s": "Recursive algorithm", "p": "Compare", "o": "Iterative algorithm", "id": 4, "concept": "recursive algorithm appendix"}
{"s": "Recursive algorithm", "p": "Part-of", "o": "Algorithm", "id": 4, "concept": "recursive algorithm appendix"}
{"s": "Recursive algorithm", "p": "Used-for", "o": "Tree", "id": 4, "concept": "recursive algorithm appendix"}
{"s": "Recursive algorithm", "p": "Evaluate-for", "o": "Run time efficiency", "id": 4, "concept": "recursive algorithm appendix"}
{"s": "Algorithm", "p": "Conjunction", "o": "Recursive algorithm", "id": 4, "concept": "recursive algorithm appendix"}
{"s": "Algorithm", "p": "Conjunction", "o": "Iterative algorithm", "id": 4, "concept": "recursive algorithm appendix"}
{"s": "Recursive algorithm", "p": "Is-a-Prerequisite-of", "o": "Appendix C", "id": 5, "concept": "return list return"}
{"s": "Recursive algorithm", "p": "Compare", "o": "Iterative algorithms", "id": 5, "concept": "return list return"}
{"s": "Recursive algorithm", "p": "Part-of", "o": "Algorithm", "id": 5, "concept": "return list return"}
{"s": "Recursive algorithm", "p": "Used-for", "o": "Tree", "id": 5, "concept": "return list return"}
{"s": "Recursive algorithm", "p": "Evaluate-for", "o": "Large data structures", "id": 5, "concept": "return list return"}
{"s": "Algorithm", "p": "Part-of", "o": "Computer science", "id": 5, "concept": "return list return"}
{"s": "Iterative algorithms", "p": "Compare", "o": "Recursive algorithms", "id": 5, "concept": "return list return"}
{"s": "Recursive algorithm", "p": "Is-a-Prerequisite-of", "o": "Appendix C", "id": 6, "concept": "given set"}
{"s": "Recursive algorithm", "p": "Compare", "o": "Iterative algorithms", "id": 6, "concept": "given set"}
{"s": "Recursive algorithm", "p": "Part-of", "o": "Algorithm", "id": 6, "concept": "given set"}
{"s": "Recursive algorithm", "p": "Used-for", "o": "Tree", "id": 6, "concept": "given set"}
{"s": "Recursive algorithm", "p": "Evaluate-for", "o": "Run time efficiency", "id": 6, "concept": "given set"}
{"s": "Recursive algorithm", "p": "Conjunction", "o": "Algorithm", "id": 6, "concept": "given set"}
{"s": "Recursive algorithm", "p": "Is-a-Prerequisite-of", "o": "Algorithm", "id": 7, "concept": "pivot list pivot list"}
{"s": "Recursive algorithm", "p": "Compare", "o": "Iterative algorithm", "id": 7, "concept": "pivot list pivot list"}
{"s": "Recursive algorithm", "p": "Part-of", "o": "Algorithm", "id": 7, "concept": "pivot list pivot list"}
{"s": "Recursive algorithm", "p": "Used-for", "o": "Tree", "id": 7, "concept": "pivot list pivot list"}
{"s": "Recursive algorithm", "p": "Evaluate-for", "o": "Run time efficiency", "id": 7, "concept": "pivot list pivot list"}
{"s": "Algorithm", "p": "Conjunction", "o": "Recursive algorithm", "id": 7, "concept": "pivot list pivot list"}
{"s": "Algorithm", "p": "Conjunction", "o": "Iterative algorithm", "id": 7, "concept": "pivot list pivot list"}
{"s": "Recursive algorithm", "p": "Is-a-Prerequisite-of", "o": "Appendix C", "id": 8, "concept": "problem author come"}
{"s": "Recursive algorithm", "p": "Compare", "o": "Iterative algorithm", "id": 8, "concept": "problem author come"}
{"s": "Recursive algorithm", "p": "Part-of", "o": "Algorithm", "id": 8, "concept": "problem author come"}
{"s": "Recursive algorithm", "p": "Used-for", "o": "Large data structures", "id": 8, "concept": "problem author come"}
{"s": "Recursive algorithm", "p": "Used-for", "o": "Tree", "id": 8, "concept": "problem author come"}
{"s": "Iterative algorithm", "p": "Compare", "o": "Recursive algorithm", "id": 8, "concept": "problem author come"}
{"s": "Algorithm", "p": "Part-of", "o": "Recursive algorithm", "id": 8, "concept": "problem author come"}
{"s": "Algorithm", "p": "Part-of", "o": "Iterative algorithm", "id": 8, "concept": "problem author come"}
{"s": "Recursive algorithm", "p": "Is-a-Prerequisite-of", "o": "Algorithm", "id": 9, "concept": "list index item index"}
{"s": "Recursive algorithm", "p": "Compare", "o": "Iterative algorithm", "id": 9, "concept": "list index item index"}
{"s": "Recursive algorithm", "p": "Part-of", "o": "Algorithm", "id": 9, "concept": "list index item index"}
{"s": "Recursive algorithm", "p": "Used-for", "o": "Tree", "id": 9, "concept": "list index item index"}
{"s": "Recursive algorithm", "p": "Evaluate-for", "o": "Run time efficiency", "id": 9, "concept": "list index item index"}
{"s": "Algorithm", "p": "Conjunction", "o": "Recursive algorithm", "id": 9, "concept": "list index item index"}
{"s": "Algorithm", "p": "Conjunction", "o": "Iterative algorithm", "id": 9, "concept": "list index item index"}
{"s": "unit test", "p": "Is-a-Prerequisite-of", "o": "software development", "id": 0, "concept": "test unit test"}
{"s": "unit test", "p": "Used-for", "o": "code coverage", "id": 0, "concept": "test unit test"}
{"s": "unit test", "p": "Compare", "o": "integration test", "id": 0, "concept": "test unit test"}
{"s": "unit test", "p": "Part-of", "o": "test suite", "id": 0, "concept": "test unit test"}
{"s": "code coverage", "p": "Evaluate-for", "o": "unit test", "id": 0, "concept": "test unit test"}
{"s": "unit test", "p": "Is-a-Prerequisite-of", "o": "software development", "id": 1, "concept": "right one ten hundred"}
{"s": "unit test", "p": "Part-of", "o": "test suite", "id": 1, "concept": "right one ten hundred"}
{"s": "unit test", "p": "Evaluate-for", "o": "boundary conditions", "id": 1, "concept": "right one ten hundred"}
{"s": "unit test", "p": "Compare", "o": "integration test", "id": 1, "concept": "right one ten hundred"}
{"s": "unit test", "p": "Used-for", "o": "TDD", "id": 1, "concept": "right one ten hundred"}
{"s": "TDD", "p": "Is-a-Prerequisite-of", "o": "unit test", "id": 1, "concept": "right one ten hundred"}
{"s": "code coverage", "p": "Part-of", "o": "unit testing", "id": 1, "concept": "right one ten hundred"}
{"s": "unit test", "p": "Is-a-Prerequisite-of", "o": "software development", "id": 2, "concept": "overwhelming list concern"}
{"s": "unit test", "p": "Part-of", "o": "test suite", "id": 2, "concept": "overwhelming list concern"}
{"s": "unit test", "p": "Evaluate-for", "o": "boundary conditions", "id": 2, "concept": "overwhelming list concern"}
{"s": "unit test", "p": "Compare", "o": "integration test", "id": 2, "concept": "overwhelming list concern"}
{"s": "unit test", "p": "Used-for", "o": "TDD", "id": 2, "concept": "overwhelming list concern"}
{"s": "TDD", "p": "Is-a-Prerequisite-of", "o": "code coverage", "id": 2, "concept": "overwhelming list concern"}
{"s": "unit test", "p": "Is-a-Prerequisite-of", "o": "software production code", "id": 2, "concept": "overwhelming list concern"}
{"s": "unit test", "p": "Conjunction", "o": "integration test", "id": 2, "concept": "overwhelming list concern"}
{"s": "unit test", "p": "Is-a-Prerequisite-of", "o": "software development", "id": 3, "concept": "thousand \ufb01nal"}
{"s": "unit test", "p": "Part-of", "o": "test suite", "id": 3, "concept": "thousand \ufb01nal"}
{"s": "unit test", "p": "Evaluate-for", "o": "boundary conditions", "id": 3, "concept": "thousand \ufb01nal"}
{"s": "unit test", "p": "Compare", "o": "integration test", "id": 3, "concept": "thousand \ufb01nal"}
{"s": "unit test", "p": "Used-for", "o": "TDD", "id": 3, "concept": "thousand \ufb01nal"}
{"s": "test suite", "p": "Conjunction", "o": "unit tests", "id": 3, "concept": "thousand \ufb01nal"}
{"s": "code coverage", "p": "Evaluate-for", "o": "unit tests", "id": 3, "concept": "thousand \ufb01nal"}
{"s": "unit test", "p": "Is-a-Prerequisite-of", "o": "software development", "id": 4, "concept": "return true return false"}
{"s": "unit test", "p": "Used-for", "o": "code coverage", "id": 4, "concept": "return true return false"}
{"s": "unit test", "p": "Compare", "o": "integration test", "id": 4, "concept": "return true return false"}
{"s": "unit test", "p": "Part-of", "o": "test suite", "id": 4, "concept": "return true return false"}
{"s": "unit test", "p": "Evaluate-for", "o": "boundary conditions", "id": 4, "concept": "return true return false"}
{"s": "heap", "p": "Part-of", "o": "heap array", "id": 0, "concept": "heap heap array"}
{"s": "heap array", "p": "Used-for", "o": "storing heap items", "id": 0, "concept": "heap heap array"}
{"s": "heap array", "p": "Part-of", "o": "heap", "id": 0, "concept": "heap heap array"}
{"s": "item", "p": "Part-of", "o": "heap", "id": 0, "concept": "heap heap array"}
{"s": "heap", "p": "Used-for", "o": "returning item at index 0", "id": 0, "concept": "heap heap array"}
{"s": "heap", "p": "Part-of", "o": "heap array", "id": 1, "concept": "respective data structure"}
{"s": "heap array", "p": "Used-for", "o": "storing heap items", "id": 1, "concept": "respective data structure"}
{"s": "heap array", "p": "Part-of", "o": "heap", "id": 1, "concept": "respective data structure"}
{"s": "heap", "p": "Part-of", "o": "heap array", "id": 2, "concept": "heap array"}
{"s": "heap array", "p": "Used-for", "o": "storing heap items", "id": 2, "concept": "heap array"}
{"s": "heap array", "p": "Part-of", "o": "backing heap array", "id": 2, "concept": "heap array"}
{"s": "garbage values", "p": "Part-of", "o": "backing heap array data", "id": 2, "concept": "heap array"}
{"s": "heap array", "p": "Evaluate-for", "o": "minimising impact of dynamic resizing", "id": 2, "concept": "heap array"}
{"s": "heap", "p": "Part-of", "o": "heap array", "id": 3, "concept": "return item list"}
{"s": "heap array", "p": "Used-for", "o": "storing heap items", "id": 3, "concept": "return item list"}
{"s": "heap array", "p": "Compare", "o": "array", "id": 3, "concept": "return item list"}
{"s": "heap array", "p": "Evaluate-for", "o": "minimising memory impact", "id": 3, "concept": "return item list"}
{"s": "heap", "p": "Part-of", "o": "heap array", "id": 4, "concept": "appendix recursive v iterative"}
{"s": "heap array", "p": "Used-for", "o": "storing heap items", "id": 4, "concept": "appendix recursive v iterative"}
{"s": "heap", "p": "Evaluate-for", "o": "searching", "id": 4, "concept": "appendix recursive v iterative"}
{"s": "heap array", "p": "Compare", "o": "array", "id": 4, "concept": "appendix recursive v iterative"}
{"s": "heap", "p": "Used-for", "o": "returning item at index 0", "id": 4, "concept": "appendix recursive v iterative"}
{"s": "Big Oh notation", "p": "Used-for", "o": "Run time complexity analysis", "id": 0, "concept": "big oh notation"}
{"s": "Big Oh notation", "p": "Is-a-Prerequisite-of", "o": "Algorithm analysis", "id": 0, "concept": "big oh notation"}
{"s": "Big Oh notation", "p": "Compare", "o": "Algorithm", "id": 0, "concept": "big oh notation"}
{"s": "Big Oh notation", "p": "Used-for", "o": "Communication", "id": 0, "concept": "big oh notation"}
{"s": "Algorithm", "p": "Part-of", "o": "Computer Science", "id": 0, "concept": "big oh notation"}
{"s": "Big Oh notation", "p": "Is-a-Prerequisite-of", "o": "Algorithm analysis", "id": 1, "concept": "radix sort unlike sorting"}
{"s": "Big Oh notation", "p": "Used-for", "o": "Run time complexity analysis", "id": 1, "concept": "radix sort unlike sorting"}
{"s": "Big Oh notation", "p": "Compare", "o": "Algorithm", "id": 1, "concept": "radix sort unlike sorting"}
{"s": "Big Oh notation", "p": "Used-for", "o": "Communication", "id": 1, "concept": "radix sort unlike sorting"}
{"s": "Factorial", "p": "Used-for", "o": "Algorithm", "id": 1, "concept": "radix sort unlike sorting"}
{"s": "big oh notation", "p": "Used-for", "o": "runtime complexity analysis", "id": 2, "concept": "custom type check type"}
{"s": "big oh notation", "p": "Compare", "o": "algorithm", "id": 2, "concept": "custom type check type"}
{"s": "algorithm", "p": "Is-a-Prerequisite-of", "o": "big oh notation", "id": 2, "concept": "custom type check type"}
{"s": "Big Oh notation", "p": "Is-a-Prerequisite-of", "o": "Algorithm analysis", "id": 3, "concept": "list algorithm remove"}
{"s": "Big Oh notation", "p": "Used-for", "o": "Run time complexity analysis", "id": 3, "concept": "list algorithm remove"}
{"s": "Big Oh notation", "p": "Compare", "o": "Algorithm", "id": 3, "concept": "list algorithm remove"}
{"s": "Big Oh notation", "p": "Used-for", "o": "Communication", "id": 3, "concept": "list algorithm remove"}
{"s": "Algorithm", "p": "Part-of", "o": "Computer science", "id": 3, "concept": "list algorithm remove"}
{"s": "big oh notation", "p": "Used-for", "o": "runtime complexity analysis", "id": 4, "concept": "requires data structure"}
{"s": "big oh notation", "p": "Compare", "o": "algorithm", "id": 4, "concept": "requires data structure"}
{"s": "algorithm", "p": "Is-a-Prerequisite-of", "o": "big oh notation", "id": 4, "concept": "requires data structure"}
{"s": "Big Oh notation", "p": "Is-a-Prerequisite-of", "o": "Run time complexity analysis", "id": 5, "concept": "yield value return root"}
{"s": "Big Oh notation", "p": "Used-for", "o": "Algorithm analysis", "id": 5, "concept": "yield value return root"}
{"s": "Big Oh notation", "p": "Compare", "o": "Algorithm", "id": 5, "concept": "yield value return root"}
{"s": "Big Oh notation", "p": "Used-for", "o": "Communication", "id": 5, "concept": "yield value return root"}
{"s": "Algorithm", "p": "Part-of", "o": "Run time complexity analysis", "id": 5, "concept": "yield value return root"}
{"s": "Big Oh notation", "p": "Is-a-Prerequisite-of", "o": "Algorithm analysis", "id": 7, "concept": "vast concern"}
{"s": "Big Oh notation", "p": "Used-for", "o": "Runtime complexity analysis", "id": 7, "concept": "vast concern"}
{"s": "Big Oh notation", "p": "Compare", "o": "Algorithm", "id": 7, "concept": "vast concern"}
{"s": "Algorithm", "p": "Used-for", "o": "Factorial calculation", "id": 7, "concept": "vast concern"}
{"s": "Big Oh notation", "p": "Is-a-Prerequisite-of", "o": "Run time complexity analysis", "id": 8, "concept": "thinking style functional"}
{"s": "Big Oh notation", "p": "Used-for", "o": "Algorithm analysis", "id": 8, "concept": "thinking style functional"}
{"s": "Big Oh notation", "p": "Compare", "o": "Algorithm", "id": 8, "concept": "thinking style functional"}
{"s": "Big Oh notation", "p": "Used-for", "o": "Communication", "id": 8, "concept": "thinking style functional"}
{"s": "Algorithm", "p": "Part-of", "o": "Run time complexity analysis", "id": 8, "concept": "thinking style functional"}
{"s": "Big Oh notation", "p": "Is-a-Prerequisite-of", "o": "Algorithm analysis", "id": 9, "concept": "string operate"}
{"s": "Big Oh notation", "p": "Used-for", "o": "Run time complexity analysis", "id": 9, "concept": "string operate"}
{"s": "Big Oh notation", "p": "Compare", "o": "Algorithm", "id": 9, "concept": "string operate"}
{"s": "Algorithm", "p": "Part-of", "o": "Computer science", "id": 9, "concept": "string operate"}
{"s": "Algorithm analysis", "p": "Part-of", "o": "Computer science", "id": 9, "concept": "string operate"}
{"s": "list", "p": "Part-of", "o": "pivot list", "id": 0, "concept": "list pivot list"}
{"s": "pivot", "p": "Conjunction", "o": "list", "id": 0, "concept": "list pivot list"}
{"s": "list", "p": "Part-of", "o": "pivot list", "id": 1, "concept": "count list index item"}
{"s": "pivot list", "p": "Used-for", "o": "sorting", "id": 1, "concept": "count list index item"}
{"s": "pivot", "p": "Part-of", "o": "pivot list", "id": 1, "concept": "count list index item"}
{"s": "list", "p": "Part-of", "o": "pivot list", "id": 2, "concept": "link library"}
{"s": "pivot", "p": "Part-of", "o": "pivot list", "id": 2, "concept": "link library"}
{"s": "list", "p": "Part-of", "o": "pivot list", "id": 3, "concept": "nodetoremove left nodetoremove"}
{"s": "pivot list", "p": "Used-for", "o": "sorting", "id": 3, "concept": "nodetoremove left nodetoremove"}
{"s": "list", "p": "Part-of", "o": "list pivot list", "id": 4, "concept": "introduction chapter introduction chapter"}
{"s": "list", "p": "Conjunction", "o": "pivot", "id": 4, "concept": "introduction chapter introduction chapter"}
{"s": "list", "p": "Part-of", "o": "pivot list", "id": 5, "concept": "case case correct exception"}
{"s": "list", "p": "Part-of", "o": "pivot list", "id": 6, "concept": "array heap"}
{"s": "list", "p": "Part-of", "o": "pivot list", "id": 7, "concept": "left nodetoremove value"}
{"s": "list", "p": "Part-of", "o": "pivot list", "id": 8, "concept": "indicate factorial number"}
{"s": "pivot", "p": "Conjunction", "o": "list", "id": 8, "concept": "indicate factorial number"}
{"s": "string", "p": "Part-of", "o": "Figure 11.2", "id": 0, "concept": "string figure 11"}
{"s": "Figure 11.2", "p": "Part-of", "o": "array", "id": 0, "concept": "string figure 11"}
{"s": "Figure 11.4", "p": "Compare", "o": "Figure A.1", "id": 0, "concept": "string figure 11"}
{"s": "string", "p": "Conjunction", "o": "punctuation", "id": 0, "concept": "string figure 11"}
{"s": "Figure 11.2", "p": "Compare", "o": "Figure 3.5", "id": 0, "concept": "string figure 11"}
{"s": "Figure 11.2", "p": "Compare", "o": "Figure 4.8", "id": 0, "concept": "string figure 11"}
{"s": "Figure 11.2", "p": "Compare", "o": "Figure 7.2", "id": 0, "concept": "string figure 11"}
{"s": "Figure 11.2", "p": "Compare", "o": "Figure A.1", "id": 0, "concept": "string figure 11"}
{"s": "string", "p": "Part-of", "o": "array", "id": 1, "concept": "string nuance"}
{"s": "Figure 11.2", "p": "Part-of", "o": "string", "id": 1, "concept": "string nuance"}
{"s": "Figure 11.4", "p": "Compare", "o": "Figure 11.2", "id": 1, "concept": "string nuance"}
{"s": "Figure A.1", "p": "Compare", "o": "Figure 11.2", "id": 1, "concept": "string nuance"}
{"s": "Figure 3.5", "p": "Conjunction", "o": "Figure 4.8", "id": 1, "concept": "string nuance"}
{"s": "Figure 7.2", "p": "Part-of", "o": "BST", "id": 1, "concept": "string nuance"}
{"s": "BST", "p": "Is-a-Prerequisite-of", "o": "worst case scenario", "id": 1, "concept": "string nuance"}
{"s": "string", "p": "Part-of", "o": "array", "id": 2, "concept": "order deque"}
{"s": "Figure 11.2", "p": "Part-of", "o": "string", "id": 2, "concept": "order deque"}
{"s": "Figure 11.4", "p": "Compare", "o": "Figure 11.2", "id": 2, "concept": "order deque"}
{"s": "Figure A.1", "p": "Compare", "o": "Figure 11.2", "id": 2, "concept": "order deque"}
{"s": "Figure 3.5", "p": "Conjunction", "o": "Figure 4.8", "id": 2, "concept": "order deque"}
{"s": "Figure 3.5", "p": "Conjunction", "o": "Figure 7.2", "id": 2, "concept": "order deque"}
{"s": "Figure 3.5", "p": "Conjunction", "o": "Figure A.1", "id": 2, "concept": "order deque"}
{"s": "Figure 3.5", "p": "Conjunction", "o": "Figure 11.2", "id": 2, "concept": "order deque"}
{"s": "Figure 3.5", "p": "Conjunction", "o": "Figure 11.4", "id": 2, "concept": "order deque"}
{"s": "Figure 4.8", "p": "Conjunction", "o": "Figure 7.2", "id": 2, "concept": "order deque"}
{"s": "Figure 4.8", "p": "Conjunction", "o": "Figure A.1", "id": 2, "concept": "order deque"}
{"s": "Figure 4.8", "p": "Conjunction", "o": "Figure 11.2", "id": 2, "concept": "order deque"}
{"s": "Figure 4.8", "p": "Conjunction", "o": "Figure 11.4", "id": 2, "concept": "order deque"}
{"s": "Figure 7.2", "p": "Conjunction", "o": "Figure A.1", "id": 2, "concept": "order deque"}
{"s": "Figure 7.2", "p": "Conjunction", "o": "Figure 11.2", "id": 2, "concept": "order deque"}
{"s": "Figure 7.2", "p": "Conjunction", "o": "Figure 11.4", "id": 2, "concept": "order deque"}
{"s": "Figure A.1", "p": "Conjunction", "o": "Figure 11.2", "id": 2, "concept": "order deque"}
{"s": "Figure A.1", "p": "Conjunction", "o": "Figure 11.4", "id": 2, "concept": "order deque"}
{"s": "Figure 11.2", "p": "Conjunction", "o": "Figure 11.4", "id": 2, "concept": "order deque"}
{"s": "string", "p": "Part-of", "o": "Figure 11.2", "id": 3, "concept": "queue sensible implementation priority"}
{"s": "Figure 11.2", "p": "Used-for", "o": "string indexing", "id": 3, "concept": "queue sensible implementation priority"}
{"s": "Figure 11.4", "p": "Compare", "o": "Figure A.1", "id": 3, "concept": "queue sensible implementation priority"}
{"s": "Figure 7.2", "p": "Compare", "o": "Figure 11.2", "id": 3, "concept": "queue sensible implementation priority"}
{"s": "Figure 3.5", "p": "Conjunction", "o": "Figure 4.8", "id": 3, "concept": "queue sensible implementation priority"}
{"s": "Figure 4.8", "p": "Conjunction", "o": "Figure 7.2", "id": 3, "concept": "queue sensible implementation priority"}
{"s": "BST", "p": "Part-of", "o": "Figure 7.2", "id": 3, "concept": "queue sensible implementation priority"}
{"s": "Figure A.1", "p": "Compare", "o": "Figure 11.4", "id": 3, "concept": "queue sensible implementation priority"}
{"s": "string", "p": "Hyponym-Of", "o": "array", "id": 3, "concept": "queue sensible implementation priority"}
{"s": "trace table", "p": "Used-for", "o": "larger diagram", "id": 3, "concept": "queue sensible implementation priority"}
{"s": "string", "p": "Part-of", "o": "array", "id": 4, "concept": "size internal data structure"}
{"s": "Figure 11.2", "p": "Part-of", "o": "string", "id": 4, "concept": "size internal data structure"}
{"s": "Figure 11.4", "p": "Compare", "o": "Figure 11.2", "id": 4, "concept": "size internal data structure"}
{"s": "Figure A.1", "p": "Compare", "o": "Figure 11.2", "id": 4, "concept": "size internal data structure"}
{"s": "priority queue", "p": "Is-a-Prerequisite-of", "o": "custom comparer", "id": 0, "concept": "priority queue"}
{"s": "priority queue", "p": "Compare", "o": "normal queue", "id": 0, "concept": "priority queue"}
{"s": "priority queue", "p": "Part-of", "o": "heap data structure", "id": 0, "concept": "priority queue"}
{"s": "priority queue", "p": "Used-for", "o": "determining order of items", "id": 0, "concept": "priority queue"}
{"s": "heap data structure", "p": "Used-for", "o": "priority queue", "id": 0, "concept": "priority queue"}
{"s": "queue", "p": "Conjunction", "o": "priority queue", "id": 0, "concept": "priority queue"}
{"s": "deque", "p": "Compare", "o": "priority queue", "id": 0, "concept": "priority queue"}
{"s": "deque", "p": "Compare", "o": "normal queue", "id": 0, "concept": "priority queue"}
{"s": "algorithms", "p": "Conjunction", "o": "priority queue", "id": 0, "concept": "priority queue"}
{"s": "priority queue", "p": "Is-a-Prerequisite-of", "o": "custom comparer", "id": 1, "concept": "number use number digit"}
{"s": "priority queue", "p": "Compare", "o": "normal queue", "id": 1, "concept": "number use number digit"}
{"s": "priority queue", "p": "Part-of", "o": "heap data structure", "id": 1, "concept": "number use number digit"}
{"s": "heap", "p": "Used-for", "o": "priority queue", "id": 1, "concept": "number use number digit"}
{"s": "queue", "p": "Conjunction", "o": "priority queue", "id": 1, "concept": "number use number digit"}
{"s": "deque", "p": "Compare", "o": "priority queue", "id": 1, "concept": "number use number digit"}
{"s": "priority queue", "p": "Is-a-Prerequisite-of", "o": "heap data structure", "id": 2, "concept": "case correct exception"}
{"s": "priority queue", "p": "Compare", "o": "queue", "id": 2, "concept": "case correct exception"}
{"s": "queue", "p": "Part-of", "o": "priority queue", "id": 2, "concept": "case correct exception"}
{"s": "heap data structure", "p": "Used-for", "o": "priority queue", "id": 2, "concept": "case correct exception"}
{"s": "deque", "p": "Compare", "o": "priority queue", "id": 2, "concept": "case correct exception"}
{"s": "deque", "p": "Compare", "o": "queue", "id": 2, "concept": "case correct exception"}
{"s": "priority queue", "p": "Is-a-Prerequisite-of", "o": "heap data structure", "id": 3, "concept": "clari\ufb01cation wanted determine thousand"}
{"s": "priority queue", "p": "Compare", "o": "queue", "id": 3, "concept": "clari\ufb01cation wanted determine thousand"}
{"s": "heap data structure", "p": "Used-for", "o": "priority queue", "id": 3, "concept": "clari\ufb01cation wanted determine thousand"}
{"s": "queue", "p": "Conjunction", "o": "priority queue", "id": 3, "concept": "clari\ufb01cation wanted determine thousand"}
{"s": "queue", "p": "Part-of", "o": "deque", "id": 3, "concept": "clari\ufb01cation wanted determine thousand"}
{"s": "priority queue", "p": "Part-of", "o": "deque", "id": 3, "concept": "clari\ufb01cation wanted determine thousand"}
{"s": "priority queue", "p": "Is-a-Prerequisite-of", "o": "heap data structure", "id": 4, "concept": "item heap heap array"}
{"s": "priority queue", "p": "Compare", "o": "queue", "id": 4, "concept": "item heap heap array"}
{"s": "queue", "p": "Part-of", "o": "priority queue", "id": 4, "concept": "item heap heap array"}
{"s": "heap data structure", "p": "Used-for", "o": "priority queue", "id": 4, "concept": "item heap heap array"}
{"s": "deque", "p": "Compare", "o": "priority queue", "id": 4, "concept": "item heap heap array"}
{"s": "deque", "p": "Compare", "o": "queue", "id": 4, "concept": "item heap heap array"}
{"s": "required data structure", "p": "Part-of", "o": "resizing algorithms", "id": 0, "concept": "required data structure encapsulates"}
{"s": "resizing algorithms", "p": "Used-for", "o": "array", "id": 0, "concept": "required data structure encapsulates"}
{"s": "array", "p": "Part-of", "o": "data structure", "id": 0, "concept": "required data structure encapsulates"}
{"s": "Add method", "p": "Is-a-Prerequisite-of", "o": "data structure", "id": 0, "concept": "required data structure encapsulates"}
{"s": "resizing algorithms", "p": "Part-of", "o": "required data structure encapsulates", "id": 1, "concept": "list list pivot list"}
{"s": "Add method", "p": "Is-a-Prerequisite-of", "o": "data structure", "id": 1, "concept": "list list pivot list"}
{"s": "required data structure", "p": "Part-of", "o": "resizing algorithms", "id": 2, "concept": "right nodetoremove left"}
{"s": "resizing algorithms", "p": "Used-for", "o": "array", "id": 2, "concept": "right nodetoremove left"}
{"s": "array", "p": "Used-for", "o": "runtime", "id": 2, "concept": "right nodetoremove left"}
{"s": "data structure", "p": "Is-a-Prerequisite-of", "o": "Add method", "id": 2, "concept": "right nodetoremove left"}
{"s": "required data structure", "p": "Part-of", "o": "resizing algorithms", "id": 4, "concept": "respective caller method exit"}
{"s": "resizing algorithms", "p": "Used-for", "o": "array", "id": 4, "concept": "respective caller method exit"}
{"s": "array", "p": "Part-of", "o": "data structure", "id": 4, "concept": "respective caller method exit"}
{"s": "data structure", "p": "Is-a-Prerequisite-of", "o": "Add method", "id": 4, "concept": "respective caller method exit"}
{"s": "Data Structures", "p": "Used-for", "o": "make problem lot easier", "id": 0, "concept": "make problem lot easier"}
{"s": "Algorithms", "p": "Used-for", "o": "make problem lot easier", "id": 0, "concept": "make problem lot easier"}
{"s": "Data Structures", "p": "Conjunction", "o": "Algorithms", "id": 0, "concept": "make problem lot easier"}
{"s": "Chapter", "p": "Part-of", "o": "Book", "id": 2, "concept": "chapter introduction book"}
{"s": "Introduction", "p": "Part-of", "o": "Book", "id": 2, "concept": "chapter introduction book"}
{"s": "Chapter", "p": "Conjunction", "o": "Chapter", "id": 2, "concept": "chapter introduction book"}
{"s": "Introduction", "p": "Conjunction", "o": "Chapter", "id": 2, "concept": "chapter introduction book"}
{"s": "AVL tree", "p": "Is-a-Prerequisite-of", "o": "preserving tree balance", "id": 3, "concept": "tree avl"}
{"s": "AVL tree", "p": "Hyponym-Of", "o": "binary search tree", "id": 3, "concept": "tree avl"}
{"s": "AVL tree", "p": "Compare", "o": "binary search tree", "id": 3, "concept": "tree avl"}
{"s": "AVL tree", "p": "Used-for", "o": "ordered set", "id": 3, "concept": "tree avl"}
{"s": "AVL tree", "p": "Part-of", "o": "balanced binary search tree data structure", "id": 3, "concept": "tree avl"}
{"s": "AVL tree", "p": "Evaluate-for", "o": "logarithmic growth", "id": 3, "concept": "tree avl"}
{"s": "binary search tree", "p": "Part-of", "o": "subtree", "id": 3, "concept": "tree avl"}
{"s": "binary search tree", "p": "Used-for", "o": "ordered sequence", "id": 3, "concept": "tree avl"}
{"s": "Preorder traversal", "p": "Part-of", "o": "Tree Traversals", "id": 3, "concept": "tree avl"}
{"s": "Postorder traversal", "p": "Part-of", "o": "Tree Traversals", "id": 3, "concept": "tree avl"}
{"s": "Inorder traversal", "p": "Part-of", "o": "Tree Traversals", "id": 3, "concept": "tree avl"}
{"s": "Breadth First traversal", "p": "Part-of", "o": "Tree Traversals", "id": 3, "concept": "tree avl"}
{"s": "Tree Traversals", "p": "Conjunction", "o": "Preorder traversal", "id": 3, "concept": "tree avl"}
{"s": "Tree Traversals", "p": "Conjunction", "o": "Postorder traversal", "id": 3, "concept": "tree avl"}
{"s": "Tree Traversals", "p": "Conjunction", "o": "Inorder traversal", "id": 3, "concept": "tree avl"}
{"s": "Tree Traversals", "p": "Conjunction", "o": "Breadth First traversal", "id": 3, "concept": "tree avl"}
{"s": "LeftAndRightRotation", "p": "Conjunction", "o": "RightAndLeftRotation", "id": 3, "concept": "tree avl"}
{"s": "LeftAndRightRotation", "p": "Part-of", "o": "balancing algorithms", "id": 3, "concept": "tree avl"}
{"s": "RightAndLeftRotation", "p": "Part-of", "o": "balancing algorithms", "id": 3, "concept": "tree avl"}
{"s": "balancing algorithms", "p": "Used-for", "o": "AVL tree", "id": 3, "concept": "tree avl"}
{"s": "heap", "p": "Hyponym-Of", "o": "tree data structure", "id": 3, "concept": "tree avl"}
{"s": "array", "p": "Used-for", "o": "represent a tree as", "id": 3, "concept": "tree avl"}
{"s": "array representation of a tree data structure", "p": "Part-of", "o": "tree data structure", "id": 3, "concept": "tree avl"}
{"s": "optimisation compiler", "p": "Used-for", "o": "code optimization", "id": 4, "concept": "optimisation compiler widely"}
{"s": "commercial compilers", "p": "Hyponym-Of", "o": "optimisation compiler", "id": 4, "concept": "optimisation compiler widely"}
{"s": "optimisation compiler", "p": "Evaluate-for", "o": "code efficiency", "id": 4, "concept": "optimisation compiler widely"}
{"s": "code optimization", "p": "Part-of", "o": "compilation process", "id": 4, "concept": "optimisation compiler widely"}
{"s": "list", "p": "Part-of", "o": "pivot", "id": 0, "concept": "list list pivot"}
{"s": "list", "p": "Part-of", "o": "pivot", "id": 0, "concept": "list list pivot"}
{"s": "list", "p": "Part-of", "o": "pivot", "id": 0, "concept": "list list pivot"}
{"s": "list", "p": "Part-of", "o": "pivot", "id": 0, "concept": "list list pivot"}
{"s": "list", "p": "Part-of", "o": "pivot", "id": 0, "concept": "list list pivot"}
{"s": "list", "p": "Part-of", "o": "pivot", "id": 0, "concept": "list list pivot"}
{"s": "list", "p": "Part-of", "o": "pivot", "id": 0, "concept": "list list pivot"}
{"s": "list", "p": "Part-of", "o": "pivot", "id": 0, "concept": "list list pivot"}
{"s": "list", "p": "Part-of", "o": "pivot", "id": 0, "concept": "list list pivot"}
{"s": "list", "p": "Part-of", "o": "pivot", "id": 1, "concept": "binary search tree chapter"}
{"s": "list", "p": "Part-of", "o": "pivot", "id": 1, "concept": "binary search tree chapter"}
{"s": "list", "p": "Part-of", "o": "pivot", "id": 1, "concept": "binary search tree chapter"}
{"s": "list", "p": "Part-of", "o": "pivot", "id": 1, "concept": "binary search tree chapter"}
{"s": "list", "p": "Part-of", "o": "pivot", "id": 1, "concept": "binary search tree chapter"}
{"s": "list", "p": "Part-of", "o": "pivot", "id": 1, "concept": "binary search tree chapter"}
{"s": "list", "p": "Part-of", "o": "pivot", "id": 1, "concept": "binary search tree chapter"}
{"s": "list", "p": "Part-of", "o": "pivot", "id": 1, "concept": "binary search tree chapter"}
{"s": "list", "p": "Part-of", "o": "pivot", "id": 1, "concept": "binary search tree chapter"}
{"s": "list", "p": "Part-of", "o": "pivot", "id": 2, "concept": "list return item"}
{"s": "list", "p": "Part-of", "o": "pivot", "id": 2, "concept": "list return item"}
{"s": "list", "p": "Part-of", "o": "pivot", "id": 2, "concept": "list return item"}
{"s": "list", "p": "Part-of", "o": "pivot", "id": 2, "concept": "list return item"}
{"s": "list", "p": "Part-of", "o": "pivot", "id": 2, "concept": "list return item"}
{"s": "list", "p": "Part-of", "o": "pivot", "id": 2, "concept": "list return item"}
{"s": "list", "p": "Part-of", "o": "pivot", "id": 2, "concept": "list return item"}
{"s": "list", "p": "Part-of", "o": "pivot", "id": 2, "concept": "list return item"}
{"s": "list", "p": "Part-of", "o": "pivot", "id": 2, "concept": "list return item"}
{"s": "zero pre list mean", "p": "Is-a-Prerequisite-of", "o": "list processing", "id": 1, "concept": "zero pre list mean"}
{"s": "zero pre list mean", "p": "Used-for", "o": "data analysis", "id": 1, "concept": "zero pre list mean"}
{"s": "list", "p": "Part-of", "o": "zero pre list mean", "id": 1, "concept": "zero pre list mean"}
{"s": "mean", "p": "Part-of", "o": "zero pre list mean", "id": 1, "concept": "zero pre list mean"}
{"s": "pre-processing", "p": "Part-of", "o": "zero pre list mean", "id": 1, "concept": "zero pre list mean"}
{"s": "zero pre list mean", "p": "Is-a-Prerequisite-of", "o": "list processing", "id": 3, "concept": "mainstream programming language target"}
{"s": "zero pre list mean", "p": "Part-of", "o": "list", "id": 3, "concept": "mainstream programming language target"}
{"s": "zero pre list mean", "p": "Used-for", "o": "data analysis", "id": 3, "concept": "mainstream programming language target"}
{"s": "list", "p": "Part-of", "o": "data structure", "id": 3, "concept": "mainstream programming language target"}
{"s": "list", "p": "Used-for", "o": "data storage", "id": 3, "concept": "mainstream programming language target"}
{"s": "list", "p": "Compare", "o": "array", "id": 3, "concept": "mainstream programming language target"}
{"s": "list", "p": "Compare", "o": "set", "id": 3, "concept": "mainstream programming language target"}
{"s": "zero pre list mean", "p": "Is-a-Prerequisite-of", "o": "list processing", "id": 4, "concept": "explicitly state end leaving"}
{"s": "zero pre list mean", "p": "Part-of", "o": "mean calculation", "id": 4, "concept": "explicitly state end leaving"}
{"s": "list", "p": "Part-of", "o": "data structure", "id": 4, "concept": "explicitly state end leaving"}
{"s": "mean", "p": "Hyponym-Of", "o": "average", "id": 4, "concept": "explicitly state end leaving"}
{"s": "mean calculation", "p": "Used-for", "o": "data analysis", "id": 4, "concept": "explicitly state end leaving"}
{"s": "zero", "p": "Conjunction", "o": "pre", "id": 4, "concept": "explicitly state end leaving"}
{"s": "return false", "p": "Compare", "o": "return true", "id": 0, "concept": "return false return true"}
{"s": "priority queue", "p": "Is-a-Prerequisite-of", "o": "heap data structure", "id": 1, "concept": "priority queue use"}
{"s": "priority queue", "p": "Compare", "o": "queue", "id": 1, "concept": "priority queue use"}
{"s": "priority queue", "p": "Compare", "o": "deque", "id": 1, "concept": "priority queue use"}
{"s": "heap data structure", "p": "Used-for", "o": "priority queue implementation", "id": 1, "concept": "priority queue use"}
{"s": "priority queue", "p": "Part-of", "o": "queue", "id": 1, "concept": "priority queue use"}
{"s": "heap data structure", "p": "Part-of", "o": "priority queue", "id": 1, "concept": "priority queue use"}
{"s": "algorithm", "p": "Is-a-Prerequisite-of", "o": "binary tree", "id": 2, "concept": "previous algorithm consider adding"}
{"s": "Remove algorithm", "p": "Part-of", "o": "Algorithms", "id": 3, "concept": "end remove algorithm"}
{"s": "Remove algorithm", "p": "Used-for", "o": "Heap", "id": 3, "concept": "end remove algorithm"}
{"s": "Remove algorithm", "p": "Compare", "o": "Insertion algorithm", "id": 3, "concept": "end remove algorithm"}
{"s": "Remove algorithm", "p": "Compare", "o": "Deletion algorithm", "id": 3, "concept": "end remove algorithm"}
{"s": "Remove algorithm", "p": "Is-a-Prerequisite-of", "o": "Helper algorithms", "id": 3, "concept": "end remove algorithm"}
{"s": "Recursive algorithm", "p": "Hyponym-Of", "o": "Algorithm", "id": 3, "concept": "end remove algorithm"}
{"s": "Iterative algorithm", "p": "Hyponym-Of", "o": "Algorithm", "id": 3, "concept": "end remove algorithm"}
{"s": "Recursive algorithm", "p": "Compare", "o": "Iterative algorithm", "id": 3, "concept": "end remove algorithm"}
{"s": "Algorithm", "p": "Used-for", "o": "String operations", "id": 3, "concept": "end remove algorithm"}
{"s": "Algorithm", "p": "Used-for", "o": "Sorting", "id": 3, "concept": "end remove algorithm"}
{"s": "Algorithm", "p": "Used-for", "o": "Node discovery", "id": 3, "concept": "end remove algorithm"}
{"s": "Algorithm", "p": "Evaluate-for", "o": "Efficiency", "id": 3, "concept": "end remove algorithm"}
{"s": "Algorithm", "p": "Part-of", "o": "Data structure", "id": 3, "concept": "end remove algorithm"}
{"s": "Algorithm", "p": "Conjunction", "o": "Data structure", "id": 3, "concept": "end remove algorithm"}
{"s": "IsPalindrome algorithm", "p": "Part-of", "o": "Algorithms", "id": 3, "concept": "end remove algorithm"}
{"s": "IsPalindrome algorithm", "p": "Used-for", "o": "String", "id": 3, "concept": "end remove algorithm"}
{"s": "FindNode algorithm", "p": "Part-of", "o": "Algorithms", "id": 3, "concept": "end remove algorithm"}
{"s": "FindMin algorithm", "p": "Part-of", "o": "Algorithms", "id": 3, "concept": "end remove algorithm"}
{"s": "FindMax algorithm", "p": "Part-of", "o": "Algorithms", "id": 3, "concept": "end remove algorithm"}
{"s": "Preorder algorithm", "p": "Part-of", "o": "Algorithms", "id": 3, "concept": "end remove algorithm"}
{"s": "Inorder algorithm", "p": "Part-of", "o": "Algorithms", "id": 3, "concept": "end remove algorithm"}
{"s": "Insertion algorithm", "p": "Part-of", "o": "Algorithms", "id": 3, "concept": "end remove algorithm"}
{"s": "Deletion algorithm", "p": "Part-of", "o": "Algorithms", "id": 3, "concept": "end remove algorithm"}
{"s": "Resizing algorithm", "p": "Part-of", "o": "Algorithms", "id": 3, "concept": "end remove algorithm"}
{"s": "Data Structures", "p": "Part-of", "o": "Computer Science", "id": 4, "concept": "respective data structure data"}
{"s": "Singly linked lists", "p": "Hyponym-Of", "o": "Data Structures", "id": 4, "concept": "respective data structure data"}
{"s": "Recursive data structures", "p": "Hyponym-Of", "o": "Data Structures", "id": 4, "concept": "respective data structure data"}
{"s": "Tree data structure", "p": "Hyponym-Of", "o": "Data Structures", "id": 4, "concept": "respective data structure data"}
{"s": "Queues", "p": "Hyponym-Of", "o": "Data Structures", "id": 4, "concept": "respective data structure data"}
{"s": "Deque", "p": "Hyponym-Of", "o": "Data Structures", "id": 4, "concept": "respective data structure data"}
{"s": "AVL Tree", "p": "Hyponym-Of", "o": "Data Structures", "id": 4, "concept": "respective data structure data"}
{"s": "Array", "p": "Used-for", "o": "Representing tree data structure", "id": 4, "concept": "respective data structure data"}
{"s": "Array", "p": "Part-of", "o": "Deque", "id": 4, "concept": "respective data structure data"}
{"s": "Doubly linked list", "p": "Part-of", "o": "Deque", "id": 4, "concept": "respective data structure data"}
{"s": "Algorithms", "p": "Conjunction", "o": "Data Structures", "id": 4, "concept": "respective data structure data"}
{"s": "Data Structures", "p": "Is-a-Prerequisite-of", "o": "Algorithms", "id": 4, "concept": "respective data structure data"}
{"s": "pivot list", "p": "Part-of", "o": "pivot", "id": 0, "concept": "pivot list pivot"}
{"s": "yield", "p": "Compare", "o": "return", "id": 1, "concept": "list list return"}
{"s": "list", "p": "Part-of", "o": "return", "id": 1, "concept": "list list return"}
{"s": "left rotation", "p": "Conjunction", "o": "right rotation", "id": 2, "concept": "rotation subsequently"}
{"s": "self right rotation", "p": "Part-of", "o": "Tree Rotations", "id": 3, "concept": "self right rotation"}
{"s": "Tree Rotations", "p": "Part-of", "o": "BST algorithms", "id": 3, "concept": "self right rotation"}
{"s": "LeftRotation", "p": "Conjunction", "o": "RightRotation", "id": 3, "concept": "self right rotation"}
{"s": "LeftAndRightRotation", "p": "Is-a-Prerequisite-of", "o": "restoring balance in BST", "id": 3, "concept": "self right rotation"}
{"s": "RightAndLeftRotation", "p": "Is-a-Prerequisite-of", "o": "restoring balance in BST", "id": 3, "concept": "self right rotation"}
{"s": "Big Oh notation", "p": "Used-for", "o": "run time complexity analysis", "id": 3, "concept": "self right rotation"}
{"s": "Big Oh notation", "p": "Compare", "o": "other notations", "id": 3, "concept": "self right rotation"}
{"s": "pivot list", "p": "Part-of", "o": "pivot", "id": 0, "concept": "pivot list pivot"}
{"s": "yield", "p": "Compare", "o": "return", "id": 1, "concept": "list list return"}
{"s": "list", "p": "Part-of", "o": "return", "id": 1, "concept": "list list return"}
{"s": "left rotation", "p": "Conjunction", "o": "right rotation", "id": 2, "concept": "rotation subsequently"}
{"s": "self right rotation", "p": "Part-of", "o": "Tree Rotations", "id": 3, "concept": "self right rotation"}
{"s": "self right rotation", "p": "Used-for", "o": "restoring balance", "id": 3, "concept": "self right rotation"}
{"s": "Tree Rotations", "p": "Part-of", "o": "Binary Search Tree", "id": 3, "concept": "self right rotation"}
{"s": "Left Rotation", "p": "Conjunction", "o": "Right Rotation", "id": 3, "concept": "self right rotation"}
{"s": "LeftAndRightRotation", "p": "Is-a-Prerequisite-of", "o": "restoring balance", "id": 3, "concept": "self right rotation"}
{"s": "RightAndLeftRotation", "p": "Is-a-Prerequisite-of", "o": "restoring balance", "id": 3, "concept": "self right rotation"}
{"s": "Big Oh notation", "p": "Used-for", "o": "run time complexity analysis", "id": 3, "concept": "self right rotation"}
{"s": "factorial", "p": "Is-a-Prerequisite-of", "o": "mathematical operation implementation", "id": 0, "concept": "mathematical operation implementation factorial"}
{"s": "factorial", "p": "Part-of", "o": "mathematical operation", "id": 0, "concept": "mathematical operation implementation factorial"}
{"s": "1", "p": "Part-of", "o": "factorial", "id": 0, "concept": "mathematical operation implementation factorial"}
{"s": "AVL tree", "p": "Is-a-Prerequisite-of", "o": "ordered set", "id": 1, "concept": "avl tree avl tree"}
{"s": "AVL tree", "p": "Hyponym-Of", "o": "binary search tree", "id": 1, "concept": "avl tree avl tree"}
{"s": "AVL tree", "p": "Used-for", "o": "ordered set", "id": 1, "concept": "avl tree avl tree"}
{"s": "binary search tree", "p": "Compare", "o": "AVL tree", "id": 1, "concept": "avl tree avl tree"}
{"s": "case", "p": "Conjunction", "o": "yield", "id": 3, "concept": "case yield true false"}
{"s": "case", "p": "Conjunction", "o": "true", "id": 3, "concept": "case yield true false"}
{"s": "case", "p": "Conjunction", "o": "false", "id": 3, "concept": "case yield true false"}
{"s": "linked list", "p": "Part-of", "o": "data structure", "id": 4, "concept": "linked list straightforward"}
{"s": "linked list", "p": "Used-for", "o": "searching", "id": 4, "concept": "linked list straightforward"}
{"s": "linked list", "p": "Used-for", "o": "deleting", "id": 4, "concept": "linked list straightforward"}
{"s": "singly linked list", "p": "Hyponym-Of", "o": "linked list", "id": 4, "concept": "linked list straightforward"}
{"s": "Binary Search Tree", "p": "Compare", "o": "linked list", "id": 4, "concept": "linked list straightforward"}
{"s": "Shell sort", "p": "Compare", "o": "linked list", "id": 4, "concept": "linked list straightforward"}
{"s": "straightforward", "p": "Evaluate-for", "o": "algorithm", "id": 4, "concept": "linked list straightforward"}
{"s": "list", "p": "Is-a-Prerequisite-of", "o": "pre-order traversal", "id": 1, "concept": "list pre list list"}
{"s": "list", "p": "Is-a-Prerequisite-of", "o": "in-order traversal", "id": 1, "concept": "list pre list list"}
{"s": "list", "p": "Is-a-Prerequisite-of", "o": "post-order traversal", "id": 1, "concept": "list pre list list"}
{"s": "list", "p": "Part-of", "o": "Abstract Data Type", "id": 1, "concept": "list pre list list"}
{"s": "list", "p": "Used-for", "o": "data storage", "id": 1, "concept": "list pre list list"}
{"s": "list", "p": "Used-for", "o": "algorithm implementation", "id": 1, "concept": "list pre list list"}
{"s": "pre-order traversal", "p": "Compare", "o": "in-order traversal", "id": 1, "concept": "list pre list list"}
{"s": "pre-order traversal", "p": "Compare", "o": "post-order traversal", "id": 1, "concept": "list pre list list"}
{"s": "in-order traversal", "p": "Compare", "o": "post-order traversal", "id": 1, "concept": "list pre list list"}
{"s": "ordered set", "p": "Compare", "o": "unordered set", "id": 2, "concept": "order post list"}
{"s": "list", "p": "Part-of", "o": "node", "id": 2, "concept": "order post list"}
{"s": "tail", "p": "Part-of", "o": "list", "id": 2, "concept": "order post list"}
{"s": "Enqueue", "p": "Is-a-Prerequisite-of", "o": "Queue", "id": 4, "concept": "root dequeue enqueue"}
{"s": "Queue", "p": "Part-of", "o": "Array", "id": 4, "concept": "root dequeue enqueue"}
{"s": "Enqueue", "p": "Conjunction", "o": "Dequeue", "id": 4, "concept": "root dequeue enqueue"}
{"s": "algorithm described", "p": "Part-of", "o": "Algorithms", "id": 6, "concept": "algorithm described"}
{"s": "algorithm described", "p": "Is-a-Prerequisite-of", "o": "algorithm design", "id": 6, "concept": "algorithm described"}
{"s": "algorithm described", "p": "Compare", "o": "efficient searching algorithms", "id": 6, "concept": "algorithm described"}
{"s": "algorithm described", "p": "Compare", "o": "sorting algorithms", "id": 6, "concept": "algorithm described"}
{"s": "algorithm described", "p": "Used-for", "o": "solving the problem", "id": 6, "concept": "algorithm described"}
{"s": "algorithm described", "p": "Part-of", "o": "Doubly linked lists", "id": 6, "concept": "algorithm described"}
{"s": "algorithm described", "p": "Part-of", "o": "Contains algorithm", "id": 6, "concept": "algorithm described"}
{"s": "algorithm described", "p": "Part-of", "o": "System.Linq.Enumerable", "id": 6, "concept": "algorithm described"}
{"s": "algorithm described", "p": "Part-of", "o": "recursive algorithm", "id": 6, "concept": "algorithm described"}
{"s": "algorithm described", "p": "Part-of", "o": "isPrime algorithm", "id": 6, "concept": "algorithm described"}
{"s": "algorithm described", "p": "Part-of", "o": "IsPalindrome algorithm", "id": 6, "concept": "algorithm described"}
{"s": "algorithm", "p": "Hyponym-Of", "o": "sorting algorithm", "id": 6, "concept": "algorithm described"}
{"s": "algorithm", "p": "Hyponym-Of", "o": "searching algorithm", "id": 6, "concept": "algorithm described"}
{"s": "algorithm", "p": "Is-a-Prerequisite-of", "o": "algorithm design", "id": 6, "concept": "algorithm described"}
{"s": "algorithm design", "p": "Used-for", "o": "solving the problem", "id": 6, "concept": "algorithm described"}
{"s": "algorithm design", "p": "Evaluate-for", "o": "efficiency", "id": 6, "concept": "algorithm described"}
{"s": "loops", "p": "Part-of", "o": "algorithm design", "id": 6, "concept": "algorithm described"}
{"s": "queue", "p": "Compare", "o": "implicitly described queue", "id": 6, "concept": "algorithm described"}
{"s": "radix sort", "p": "Compare", "o": "sorting algorithms", "id": 6, "concept": "algorithm described"}
{"s": "Preorder", "p": "Part-of", "o": "Tree Traversal", "id": 7, "concept": "left preorder root left"}
{"s": "Preorder", "p": "Conjunction", "o": "Postorder", "id": 7, "concept": "left preorder root left"}
{"s": "Preorder", "p": "Conjunction", "o": "Inorder", "id": 7, "concept": "left preorder root left"}
{"s": "Left", "p": "Part-of", "o": "Binary Tree", "id": 7, "concept": "left preorder root left"}
{"s": "root", "p": "Part-of", "o": "Binary Tree", "id": 7, "concept": "left preorder root left"}
{"s": "Preorder", "p": "Is-a-Prerequisite-of", "o": "Left subtree traversal", "id": 7, "concept": "left preorder root left"}
{"s": "Inorder", "p": "Is-a-Prerequisite-of", "o": "Left subtree traversal", "id": 7, "concept": "left preorder root left"}
{"s": "Postorder", "p": "Is-a-Prerequisite-of", "o": "Left subtree traversal", "id": 7, "concept": "left preorder root left"}
{"s": "Preorder", "p": "Part-of", "o": "Tree Traversal", "id": 8, "concept": "preorder root right postorder"}
{"s": "Postorder", "p": "Part-of", "o": "Tree Traversal", "id": 8, "concept": "preorder root right postorder"}
{"s": "Inorder", "p": "Part-of", "o": "Tree Traversal", "id": 8, "concept": "preorder root right postorder"}
{"s": "Preorder", "p": "Conjunction", "o": "Postorder", "id": 8, "concept": "preorder root right postorder"}
{"s": "Preorder", "p": "Conjunction", "o": "Inorder", "id": 8, "concept": "preorder root right postorder"}
{"s": "Postorder", "p": "Conjunction", "o": "Inorder", "id": 8, "concept": "preorder root right postorder"}
{"s": "Right", "p": "Part-of", "o": "Binary Tree", "id": 8, "concept": "preorder root right postorder"}
{"s": "Preorder", "p": "Used-for", "o": "Tree Traversal", "id": 8, "concept": "preorder root right postorder"}
{"s": "Postorder", "p": "Used-for", "o": "Tree Traversal", "id": 8, "concept": "preorder root right postorder"}
{"s": "Inorder", "p": "Used-for", "o": "Tree Traversal", "id": 8, "concept": "preorder root right postorder"}
{"s": "represent type", "p": "Is-a-Prerequisite-of", "o": "data structure", "id": 2, "concept": "represent type"}
{"s": "data structure", "p": "Part-of", "o": "array", "id": 2, "concept": "represent type"}
{"s": "array", "p": "Used-for", "o": "represent tree", "id": 2, "concept": "represent type"}
{"s": "tree", "p": "Hyponym-Of", "o": "data structure", "id": 2, "concept": "represent type"}
{"s": "binary search tree", "p": "Hyponym-Of", "o": "tree", "id": 2, "concept": "represent type"}
{"s": "Algorithm", "p": "Used-for", "o": "represent type", "id": 2, "concept": "represent type"}
{"s": "Algorithm", "p": "Evaluate-for", "o": "data structure", "id": 2, "concept": "represent type"}
{"s": "heap", "p": "Hyponym-Of", "o": "data structure", "id": 2, "concept": "represent type"}
{"s": "AVL tree", "p": "Hyponym-Of", "o": "binary search tree", "id": 2, "concept": "represent type"}
{"s": "node", "p": "Part-of", "o": "binary search tree", "id": 2, "concept": "represent type"}
{"s": "string", "p": "Hyponym-Of", "o": "data structure", "id": 2, "concept": "represent type"}
{"s": "string", "p": "Part-of", "o": "contiguous memory", "id": 2, "concept": "represent type"}
{"s": "array", "p": "Used-for", "o": "represent string", "id": 2, "concept": "represent type"}
{"s": "recursive algorithm", "p": "Compare", "o": "iterative algorithm", "id": 2, "concept": "represent type"}
{"s": "base 2 representation", "p": "Hyponym-Of", "o": "representation", "id": 2, "concept": "represent type"}
{"s": "post-condition", "p": "Part-of", "o": "algorithm", "id": 2, "concept": "represent type"}
{"s": "list", "p": "Part-of", "o": "pivot", "id": 3, "concept": "list pivot list pivot"}
{"s": "problem", "p": "Used-for", "o": "algorithm", "id": 4, "concept": "problem algorithm use"}
{"s": "algorithm", "p": "Part-of", "o": "node discovery", "id": 4, "concept": "problem algorithm use"}
{"s": "algorithm", "p": "Compare", "o": "algorithm", "id": 4, "concept": "problem algorithm use"}
{"s": "algorithm", "p": "Is-a-Prerequisite-of", "o": "sorting", "id": 4, "concept": "problem algorithm use"}
{"s": "algorithm", "p": "Is-a-Prerequisite-of", "o": "string operations", "id": 4, "concept": "problem algorithm use"}
{"s": "FindNode algorithm", "p": "Is-a-Prerequisite-of", "o": "preorder algorithm", "id": 4, "concept": "problem algorithm use"}
{"s": "Remove algorithm", "p": "Used-for", "o": "heap", "id": 4, "concept": "problem algorithm use"}
{"s": "algorithm", "p": "Hyponym-Of", "o": "sorting algorithm", "id": 4, "concept": "problem algorithm use"}
{"s": "algorithm", "p": "Compare", "o": "recursive algorithm", "id": 4, "concept": "problem algorithm use"}
{"s": "algorithm", "p": "Used-for", "o": "integer", "id": 4, "concept": "problem algorithm use"}
{"s": "algorithm", "p": "Used-for", "o": "list", "id": 4, "concept": "problem algorithm use"}
{"s": "IsPalindrome algorithm", "p": "Used-for", "o": "string", "id": 4, "concept": "problem algorithm use"}
{"s": "Strip", "p": "Part-of", "o": "IsPalindrome algorithm", "id": 4, "concept": "problem algorithm use"}
{"s": "IsPalindrome algorithm", "p": "Evaluate-for", "o": "robustness", "id": 4, "concept": "problem algorithm use"}
{"s": "IsPalindrome algorithm", "p": "Used-for", "o": "variables", "id": 4, "concept": "problem algorithm use"}
{"s": "String algorithm", "p": "Part-of", "o": "Algorithms", "id": 5, "concept": "chapter 11 string algorithm"}
{"s": "String algorithm", "p": "Is-a-Prerequisite-of", "o": "structured approach", "id": 5, "concept": "chapter 11 string algorithm"}
{"s": "String algorithm", "p": "Used-for", "o": "tracing", "id": 5, "concept": "chapter 11 string algorithm"}
{"s": "Algorithms", "p": "Conjunction", "o": "Sorting algorithms", "id": 5, "concept": "chapter 11 string algorithm"}
{"s": "Insertion sort", "p": "Hyponym-Of", "o": "Sorting algorithms", "id": 5, "concept": "chapter 11 string algorithm"}
{"s": "Binary chop", "p": "Hyponym-Of", "o": "Searching algorithm", "id": 5, "concept": "chapter 11 string algorithm"}
{"s": "Sorting algorithms", "p": "Compare", "o": "Searching algorithm", "id": 5, "concept": "chapter 11 string algorithm"}
{"s": "root", "p": "Is-a-Prerequisite-of", "o": "CheckBalance", "id": 6, "concept": "root root node bst"}
{"s": "root node", "p": "Part-of", "o": "tree", "id": 6, "concept": "root root node bst"}
{"s": "CheckBalance", "p": "Used-for", "o": "root node", "id": 6, "concept": "root root node bst"}
{"s": "String", "p": "Part-of", "o": "Array", "id": 7, "concept": "string number"}
{"s": "String", "p": "Used-for", "o": "IsPalindrome", "id": 7, "concept": "string number"}
{"s": "Integer", "p": "Conjunction", "o": "String", "id": 7, "concept": "string number"}
{"s": "String", "p": "Compare", "o": "Number", "id": 7, "concept": "string number"}
{"s": "IsPalindrome", "p": "Used-for", "o": "String", "id": 7, "concept": "string number"}
{"s": "nodeToRemove", "p": "Part-of", "o": "linked list", "id": 8, "concept": "left nodetoremove right"}
{"s": "nodeToRemove", "p": "Part-of", "o": "binary search tree", "id": 8, "concept": "left nodetoremove right"}
{"s": "Left", "p": "Part-of", "o": "nodeToRemove", "id": 8, "concept": "left nodetoremove right"}
{"s": "Right", "p": "Part-of", "o": "nodeToRemove", "id": 8, "concept": "left nodetoremove right"}
{"s": "nodeToRemove.Left", "p": "Is-a-Prerequisite-of", "o": "nodeToRemove.Right", "id": 8, "concept": "left nodetoremove right"}
{"s": "nodeToRemove.Right", "p": "Is-a-Prerequisite-of", "o": "nodeToRemove.Left", "id": 8, "concept": "left nodetoremove right"}
{"s": "parent", "p": "Part-of", "o": "binary search tree", "id": 8, "concept": "left nodetoremove right"}
{"s": "largestValue", "p": "Part-of", "o": "nodeToRemove.Left", "id": 8, "concept": "left nodetoremove right"}
{"s": "Left", "p": "Conjunction", "o": "Right", "id": 8, "concept": "left nodetoremove right"}
{"s": "introduction", "p": "Part-of", "o": "book outline", "id": 9, "concept": "introduction book outline"}
{"s": "Deque", "p": "Compare", "o": "Queue", "id": 0, "concept": "item deque respect algorithmic"}
{"s": "Deque", "p": "Is-a-Prerequisite-of", "o": "Algorithm", "id": 0, "concept": "item deque respect algorithmic"}
{"s": "Algorithm", "p": "Part-of", "o": "Computer Science", "id": 0, "concept": "item deque respect algorithmic"}
{"s": "Algorithm", "p": "Used-for", "o": "Run Time Complexity Analysis", "id": 0, "concept": "item deque respect algorithmic"}
{"s": "Big Oh notation", "p": "Is-a-Prerequisite-of", "o": "Algorithm analysis", "id": 2, "concept": "oh notation run"}
{"s": "Big Oh notation", "p": "Used-for", "o": "Run time complexity analysis", "id": 2, "concept": "oh notation run"}
{"s": "Big Oh notation", "p": "Compare", "o": "Algorithm", "id": 2, "concept": "oh notation run"}
{"s": "Algorithm", "p": "Part-of", "o": "Run time complexity analysis", "id": 2, "concept": "oh notation run"}
{"s": "Big Oh notation", "p": "Used-for", "o": "Communication", "id": 2, "concept": "oh notation run"}
{"s": "Set", "p": "Conjunction", "o": "Big Oh notation", "id": 2, "concept": "oh notation run"}
{"s": "Height", "p": "Part-of", "o": "Tree", "id": 4, "concept": "height current left height"}
{"s": "Height", "p": "Used-for", "o": "Balancing", "id": 4, "concept": "height current left height"}
{"s": "Left", "p": "Part-of", "o": "Tree", "id": 4, "concept": "height current left height"}
{"s": "Height", "p": "Compare", "o": "Height", "id": 4, "concept": "height current left height"}
{"s": "Left", "p": "Compare", "o": "Right", "id": 4, "concept": "height current left height"}
{"s": "Recursive algorithm", "p": "Is-a-Prerequisite-of", "o": "Stack size", "id": 5, "concept": "recursive algorithm operating"}
{"s": "Recursive algorithm", "p": "Used-for", "o": "Tree", "id": 5, "concept": "recursive algorithm operating"}
{"s": "Recursive algorithm", "p": "Compare", "o": "Iterative algorithm", "id": 5, "concept": "recursive algorithm operating"}
{"s": "Recursive algorithm", "p": "Part-of", "o": "Algorithm", "id": 5, "concept": "recursive algorithm operating"}
{"s": "Data structure", "p": "Used-for", "o": "Recursive algorithm", "id": 5, "concept": "recursive algorithm operating"}
{"s": "Diagram", "p": "Used-for", "o": "Recursive algorithm", "id": 5, "concept": "recursive algorithm operating"}
{"s": "Recursive algorithm", "p": "Evaluate-for", "o": "Efficiency", "id": 5, "concept": "recursive algorithm operating"}
{"s": "Algorithm", "p": "Part-of", "o": "Recursive algorithm", "id": 5, "concept": "recursive algorithm operating"}
{"s": "set", "p": "Used-for", "o": "hash table", "id": 6, "concept": "set e\ufb03ciently implemented"}
{"s": "hash table", "p": "Part-of", "o": "set", "id": 6, "concept": "set e\ufb03ciently implemented"}
{"s": "queue", "p": "Compare", "o": "set", "id": 6, "concept": "set e\ufb03ciently implemented"}
{"s": "ordered set", "p": "Is-a-Prerequisite-of", "o": "AVL tree", "id": 8, "concept": "ordered set"}
{"s": "ordered set", "p": "Compare", "o": "unordered set", "id": 8, "concept": "ordered set"}
{"s": "ordered set", "p": "Part-of", "o": "binary search tree", "id": 8, "concept": "ordered set"}
{"s": "inorder traversal", "p": "Used-for", "o": "ordered set", "id": 8, "concept": "ordered set"}
{"s": "unordered set", "p": "Compare", "o": "ordered set", "id": 8, "concept": "ordered set"}
{"s": "hash table", "p": "Used-for", "o": "unordered set", "id": 8, "concept": "ordered set"}
{"s": "AVL tree", "p": "Part-of", "o": "ordered set", "id": 8, "concept": "ordered set"}
{"s": "ordered list", "p": "Conjunction", "o": "ordered list", "id": 8, "concept": "ordered set"}
{"s": "Doubly linked lists", "p": "Compare", "o": "Singly linked lists", "id": 0, "concept": "pre list pre"}
{"s": "Singly linked lists", "p": "Used-for", "o": "Insertion", "id": 0, "concept": "pre list pre"}
{"s": "Doubly linked lists", "p": "Used-for", "o": "Insertion", "id": 0, "concept": "pre list pre"}
{"s": "Singly linked lists", "p": "Evaluate-for", "o": "Random insertion", "id": 0, "concept": "pre list pre"}
{"s": "Doubly linked lists", "p": "Evaluate-for", "o": "Random insertion", "id": 0, "concept": "pre list pre"}
{"s": "Doubly linked lists", "p": "Part-of", "o": "Linked lists", "id": 0, "concept": "pre list pre"}
{"s": "Singly linked lists", "p": "Part-of", "o": "Linked lists", "id": 0, "concept": "pre list pre"}
{"s": "implementation", "p": "Is-a-Prerequisite-of", "o": "algorithm", "id": 2, "concept": "implementation factorial"}
{"s": "recursive implementation", "p": "Is-a-Prerequisite-of", "o": "factorial", "id": 2, "concept": "implementation factorial"}
{"s": "implementation", "p": "Used-for", "o": "algorithm", "id": 2, "concept": "implementation factorial"}
{"s": "table based approach", "p": "Compare", "o": "recursive implementation", "id": 2, "concept": "implementation factorial"}
{"s": "heap data structure", "p": "Used-for", "o": "priority queue implementation", "id": 2, "concept": "implementation factorial"}
{"s": "heap data structure", "p": "Part-of", "o": "priority queue implementation", "id": 2, "concept": "implementation factorial"}
{"s": "C# implementation", "p": "Part-of", "o": "open source project", "id": 2, "concept": "implementation factorial"}
{"s": "linked lists", "p": "Part-of", "o": "DSA", "id": 2, "concept": "implementation factorial"}
{"s": "unordered sets", "p": "Part-of", "o": "libraries", "id": 2, "concept": "implementation factorial"}
{"s": "hash table", "p": "Used-for", "o": "implementation", "id": 2, "concept": "implementation factorial"}
{"s": "implementation", "p": "Evaluate-for", "o": "efficiency", "id": 2, "concept": "implementation factorial"}
{"s": "deque", "p": "Is-a-Prerequisite-of", "o": "ordered", "id": 3, "concept": "order deque property deque"}
{"s": "deque", "p": "Part-of", "o": "data structure", "id": 3, "concept": "order deque property deque"}
{"s": "deque", "p": "Hyponym-Of", "o": "queue", "id": 3, "concept": "order deque property deque"}
{"s": "deque", "p": "Compare", "o": "queue", "id": 3, "concept": "order deque property deque"}
{"s": "order", "p": "Is-a-Prerequisite-of", "o": "deque", "id": 3, "concept": "order deque property deque"}
{"s": "property", "p": "Conjunction", "o": "deque", "id": 3, "concept": "order deque property deque"}
{"s": "algorithm", "p": "Is-a-Prerequisite-of", "o": "return type", "id": 4, "concept": "algorithm add value"}
{"s": "algorithm", "p": "Used-for", "o": "value", "id": 4, "concept": "algorithm add value"}
{"s": "algorithm", "p": "Part-of", "o": "data structure", "id": 4, "concept": "algorithm add value"}
{"s": "recursive algorithm", "p": "Compare", "o": "non-recursive algorithm", "id": 4, "concept": "algorithm add value"}
{"s": "algorithm", "p": "Evaluate-for", "o": "efficiency", "id": 4, "concept": "algorithm add value"}
{"s": "LeftAndRightRotation", "p": "Conjunction", "o": "RightAndLeftRotation", "id": 4, "concept": "algorithm add value"}
{"s": "logarithmic searching algorithm", "p": "Used-for", "o": "AVL tree", "id": 4, "concept": "algorithm add value"}
{"s": "logarithmic searching algorithm", "p": "Used-for", "o": "BST tree", "id": 4, "concept": "algorithm add value"}
{"s": "Add", "p": "Hyponym-Of", "o": "algorithm", "id": 4, "concept": "algorithm add value"}
{"s": "MaxValue", "p": "Hyponym-Of", "o": "algorithm", "id": 4, "concept": "algorithm add value"}
{"s": "problem", "p": "Part-of", "o": "algorithm", "id": 5, "concept": "problem author"}
{"s": "problem", "p": "Used-for", "o": "diagram", "id": 5, "concept": "problem author"}
{"s": "algorithm", "p": "Compare", "o": "algorithm", "id": 5, "concept": "problem author"}
{"s": "problem", "p": "Is-a-Prerequisite-of", "o": "algorithm", "id": 5, "concept": "problem author"}
{"s": "smaller problems", "p": "Conjunction", "o": "problem", "id": 5, "concept": "problem author"}
{"s": "problem", "p": "Evaluate-for", "o": "algorithm", "id": 5, "concept": "problem author"}
{"s": "Big Oh notation", "p": "Is-a-Prerequisite-of", "o": "Algorithm analysis", "id": 6, "concept": "oh notation big oh"}
{"s": "Big Oh notation", "p": "Used-for", "o": "Comparing algorithm efficiency", "id": 6, "concept": "oh notation big oh"}
{"s": "Big Oh notation", "p": "Used-for", "o": "Communication among computer scientists", "id": 6, "concept": "oh notation big oh"}
{"s": "Algorithm", "p": "Part-of", "o": "Computer science", "id": 6, "concept": "oh notation big oh"}
{"s": "Factorial", "p": "Compare", "o": "Algorithm runtime", "id": 6, "concept": "oh notation big oh"}
{"s": "number", "p": "Part-of", "o": "digit", "id": 7, "concept": "number consists digit"}
{"s": "number", "p": "Is-a-Prerequisite-of", "o": "digit", "id": 7, "concept": "number consists digit"}
{"s": "list index", "p": "Part-of", "o": "list", "id": 8, "concept": "list index"}
{"s": "array", "p": "Part-of", "o": "heap", "id": 8, "concept": "list index"}
{"s": "index", "p": "Used-for", "o": "SequentialSearch", "id": 8, "concept": "list index"}
{"s": "index", "p": "Used-for", "o": "ProbabilitySearch", "id": 8, "concept": "list index"}
{"s": "index", "p": "Used-for", "o": "searching", "id": 8, "concept": "list index"}
{"s": "top-of-stack index", "p": "Part-of", "o": "stack", "id": 8, "concept": "list index"}
{"s": "list index", "p": "Compare", "o": "array index", "id": 8, "concept": "list index"}
{"s": "SequentialSearch", "p": "Compare", "o": "ProbabilitySearch", "id": 8, "concept": "list index"}
{"s": "Remove algorithm", "p": "Is-a-Prerequisite-of", "o": "value", "id": 9, "concept": "value delete algorithm remove"}